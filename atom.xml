<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>arlendp</title>
  
  <subtitle>arlendp&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arlendp.me/"/>
  <updated>2018-04-15T11:06:14.852Z</updated>
  <id>http://arlendp.me/</id>
  
  <author>
    <name>arlendp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webpack打包优化</title>
    <link href="http://arlendp.me/web/js/webpack-packaging-optimization/"/>
    <id>http://arlendp.me/web/js/webpack-packaging-optimization/</id>
    <published>2017-02-05T16:00:00.000Z</published>
    <updated>2018-04-15T11:06:14.852Z</updated>
    
    <content type="html"><![CDATA[<p>前端的打包工具从之前的browserify、grunt、gulp到现如今的rollup、webpack，涌现出了很多优秀的打包工具，而目前最火的无疑是webpack，无论是当前热门的框架还是工具库很多都选择了它作为打包工具，因此在开发中webpack作为打包工具是一个很好的选择。在最近的项目开发中我也用到了webpack，其中也碰到了不少优化方面的问题，这里总结一下webpack打包优化的一些细节和方法。</p><a id="more"></a><p>首先，这次项目用到的是vue的全家桶，在webpack的配置方面直接用的是<code>vue-cli</code>生成的默认配置，项目打包完成后发现生成的<code>vendor.js</code>文件体积特别大，其次打包过程相当缓慢，因此想尝试各种方式对其进行优化。</p><h2 id="定位体积大的模块"><a href="#定位体积大的模块" class="headerlink" title="定位体积大的模块"></a>定位体积大的模块</h2><p>要想对打包体积进行优化，首先得找到体积大的模块，在这里我们可以使用webpack插件<code>webpack-bundle-analyzer</code>来查看整个项目的体积结构对比，它是以treemap的形式展现出来，很形象直观，还有一些具体的交互形式。既可以查看你项目中用到的所有依赖，也可以直观看到各个模块体积在整个项目中的占比。</p><p><img src="https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif" alt="webpack-bundle-analyzer"></p><p>该插件的使用方法可以直接通过<code>npm install webpack-bundle-analyzer --save-dev</code>安装，并在webpack的配置信息中的<code>plugins: [new BundleAnalyzerPlugin()]</code>中添加即可。对于<code>vue-cli</code>中的配置方式，默认是安装了该插件，但是没有启用，找到<code>config/index.js</code>文件在<code>build</code>下面会有<code>bundleAnalyzerReport</code>的配置，默认是<code>process.env.npm_config_report</code>，这里建议在<code>package.json</code>的<code>scripts</code>中添加一行<code>&quot;analyz&quot;: &quot;npm_config_report=true npm run build&quot;</code>，这样每次想启用该插件时只需要<code>npm run analyze</code>即可。</p><h2 id="提取公共模块"><a href="#提取公共模块" class="headerlink" title="提取公共模块"></a>提取公共模块</h2><p>对于webpack，它在模块化打包上有两点是其核心功能，一是它支持大量的模块类型，无论是<code>TypeScript</code>、<code>CoffeeScript</code>还是<code>sass</code>、<code>stylus</code>等语言它都支持，二是它可以通过配置来控制打包文件的粒度，这个下面会讲到。</p><p>在开发中我们往往会将所有的依赖库单独提取出来，而不与我们的项目代码混在一起，这时我们会用到一个webpack自带的插件<code>CommonsChunkPlugin</code>，从名字上就可以看出它是一个提取公共模块的插件。从它的文档中可以看出可以传入一个对象最为参数，在使用中常用的三个参数分别为：</p><ul><li>name(names)</li><li>minChunks</li><li>chunks</li></ul><p><code>name</code>好理解，指的就是最后打包文件的名字，而如果使用的是<code>names</code>的话，传入的必须是一个字符串数组。<code>minChunks</code>如果传入的是一个数字的话，指的是如果该模块被其他模块的引用次数达到了这个数值的话该模块就会被打包。如果传入的是一个函数的话，其返回值必须是布尔类型来指明这个模块是否应该被打包进公共模块。而<code>chunks</code>则会指定一个字符串数组，如果设置了该参数，则打包的时候只会从其中指定的模块中提取公共子模块。</p><p>下面通过几个实例来说明这个插件是如何工作的。</p><p>假设有两个模块<code>chunk1.js</code>和<code>chunk2.js</code>以及两个项目文件<code>a.js</code>和<code>b.js</code>，结构大致如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./chunk1'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./chunk2'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./chunk1'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./chunk2'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'vue'</span>);</span><br><span class="line"><span class="comment">// webpack配置如下</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./main.js'</span>, </span><br><span class="line">    main1: <span class="string">'./main1.js'</span>,        </span><br><span class="line">    jquery:[<span class="string">"jquery"</span>],     </span><br><span class="line">    vue:[<span class="string">"vue"</span>]   </span><br><span class="line">  &#125;,    </span><br><span class="line">  output: &#123;      </span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span>,   </span><br><span class="line">    filename: <span class="string">'[name].js'</span> </span><br><span class="line">  &#125;,   </span><br><span class="line">  plugins: [  </span><br><span class="line">    <span class="keyword">new</span> CommonsChunkPlugin(&#123;   </span><br><span class="line">      name: [<span class="string">"common"</span>,<span class="string">"jquery"</span>,<span class="string">"vue"</span>,<span class="string">"load"</span>],   </span><br><span class="line">      minChunks:<span class="number">2</span> </span><br><span class="line">    &#125;)   </span><br><span class="line">  ] &#125;;</span><br></pre></td></tr></table></figure><p>最终的打包结果是：<code>jquery</code>被打包到<code>jquery.js</code>，<code>vue</code>被打包到<code>vue.js</code>，<code>common.js</code>打包的是公共模块(chunk1和chunk2)。使用该插件打包时，会将满足<code>minChunks</code>的模块打包到<code>name</code>数组的第一个块里，然后数组后面的依次打包，首先从<code>entry</code>中找，如果没有则产生一个空块。<code>name</code>数组中最后一个块打包的是webpack的runtime代码，在使用的时候必须先加载该块。</p><p>现在看一看<code>vue-cli</code>对于该插件的配置文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'vendor'</span>,</span><br><span class="line">  minChunks: <span class="function"><span class="keyword">function</span> (<span class="params">module, count</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将node_modules中的依赖模块全部提取到vendor文件中</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">      <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">        path.join(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">      ) === <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// webpack在使用CommonsChunkPlugin时会生成一段runtime代码，并且打包进vendor中。</span></span><br><span class="line"><span class="comment">// 这样即使不改变vendor代码，每次打包时runtime会变化导致vendor的hash变化，这里</span></span><br><span class="line"><span class="comment">// 把独立的runtime代码抽离出来来解决这个问题</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'manifest'</span>,</span><br><span class="line">  chunks: [<span class="string">'vendor'</span>]</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><h2 id="移除不必要的文件"><a href="#移除不必要的文件" class="headerlink" title="移除不必要的文件"></a>移除不必要的文件</h2><p>在项目中我通过方法一定位到几处体积占用较大的库，其中一个便是<code>moment.js</code>这个日期处理库。对于一个日期处理的功能，为何这个库会占用如此大的体积，仔细查看发现当引用这个库的时候，所有的<code>locale</code>文件都被引入，而这些文件甚至在整个库的体积中占了大部分，因此当webpack打包时移除这部分内容会让打包文件的体积有所减小。</p><p>webpack自带的两个库可以实现这个功能：</p><ul><li>IgnorePlugin</li><li>ContextReplacementPlugin</li></ul><p><code>IgnorePlugin</code>的使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件配置</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// 忽略moment.js中所有的locale文件</span></span><br><span class="line">  <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, /moment$/),</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="comment">// 引入zh-cn locale文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'moment/locale/zh-cn'</span>);</span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>);</span><br></pre></td></tr></table></figure><p><code>ContextReplacementPlugin</code>的使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件配置</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// 只加载locale zh-cn文件</span></span><br><span class="line">  <span class="keyword">new</span> webpack.ContextReplacementPlugin(<span class="regexp">/moment[\/\\]locale$/</span>, /zh-cn/),</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>);</span><br></pre></td></tr></table></figure><p>通过以上两种方式，<code>moment.js</code>的体积大致能缩减为原来的四分之一。</p><h2 id="模块化引入"><a href="#模块化引入" class="headerlink" title="模块化引入"></a>模块化引入</h2><p>在项目中我使用了<code>lodash</code>这个很常用的工具库，然而在代码定位的时候发现这个库也占了不少的体积。仔细想想，我们在使用这类工具库的时候往往只使用到了其中的很少的一部分功能，但却把整个库都引入了。因此这里也可以进一步优化，只引用需要的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;chain, cloneDeep&#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="comment">// 可以改写为</span></span><br><span class="line"><span class="keyword">import</span> chain <span class="keyword">from</span> <span class="string">'lodash/chain'</span>;</span><br><span class="line"><span class="keyword">import</span> cloneDeep <span class="keyword">from</span> <span class="string">'lodash/cloneDeep'</span>;</span><br></pre></td></tr></table></figure><p>这样就可以只打包我们需要的部分功能。</p><h2 id="通过CDN引用"><a href="#通过CDN引用" class="headerlink" title="通过CDN引用"></a>通过CDN引用</h2><p>对于一些必要的库，但又无法对该库进行更好的体积优化的话，可以尝试通过外部引入的方式来减小打包文件的体积。采用该方法只需要在cdn站点找到需要引用的库的外部链接，以及对webpack进行简单配置即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在html中添加script引用</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里externals的key指的是使用时需要require的包名，value指的是该库通过script引入后在全局注册的变量名</span></span><br><span class="line">externals: &#123;</span><br><span class="line">  jquery: <span class="string">'jQuery'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'jquery'</span>)</span><br></pre></td></tr></table></figure><h2 id="通过DLLPlugin-和-DLLReferencePlugin-拆分文件"><a href="#通过DLLPlugin-和-DLLReferencePlugin-拆分文件" class="headerlink" title="通过DLLPlugin 和 DLLReferencePlugin 拆分文件"></a>通过<code>DLLPlugin</code> 和 <code>DLLReferencePlugin</code> 拆分文件</h2><p>如果项目过大，打包的时间会相当的长，如果频繁更新上线则会不断对代码进行编译打包，浪费很多时间。这时我们便可以将那些不常更新的框架和库(如vue.js等)进行单独的编译打包，这样每次开发上线就只需要对我们的开发文件进行编译打包，这样可以极大地省去不必要的打包时间。而这种方法需要<code>DLLPlugin</code>和<code>DLLReferencePlugin</code>两个插件的配合来完成。</p><h3 id="DLLPlugin"><a href="#DLLPlugin" class="headerlink" title="DLLPlugin"></a>DLLPlugin</h3><p>在使用这个插件时，我们需要单独创建一个配置文件，这里命名为<code>webpack.dll.config.js</code>，配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    lib: [<span class="string">'vue'</span>, <span class="string">'vuex'</span>, <span class="string">'vue-resource'</span>, <span class="string">'vue-router'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>, <span class="string">'dll'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath,</span><br><span class="line">    library: <span class="string">'[name]_library'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: <span class="string">'"production"'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * path: manifest.json输出文件路径</span></span><br><span class="line"><span class="comment">     * name: dll对象名，跟output.library保持一致</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'../dist/dll'</span>, <span class="string">'lib.manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]_library'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意几点：</p><ol><li><code>entry</code>中写明所有要单独打包的模块</li><li><code>output</code>的<code>library</code>属性可以将dll包暴露出来</li><li><code>DLLPlugin</code>的配置中，<code>path</code>指明<code>manifest.json</code>文件的生成路径，<code>name</code>暴露出dll的函数名</li></ol><p>运行该配置文件便可生成打包文件和<code>manifest.json</code>文件。</p><h3 id="DLLReferencePlugin"><a href="#DLLReferencePlugin" class="headerlink" title="DLLReferencePlugin"></a>DLLReferencePlugin</h3><p>对于该插件的配置，不需要像上面一样单独写配置文件，只需要在生产配置文件中添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;       </span><br><span class="line">  context: __dirname,                  <span class="comment">// 同dll配置的路径保持一致</span></span><br><span class="line">  manifest: <span class="built_in">require</span>(<span class="string">'../dist/dll/lib.manifest.json'</span>) <span class="comment">// manifest的位置</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>然后运行webpack，发现打包的速度得到了极大地提升，也不用每次更新代码的时候重复编译打包这些依赖库了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于webpack的打包优化我大致就总结了上面的一些方法，而为了让页面更快的加载，有更好的用户体验，我们并不只是从打包上优化，也可以有其他方面的优化，这里我也简单提一下我使用过的方法。</p><h3 id="开启Gzip压缩"><a href="#开启Gzip压缩" class="headerlink" title="开启Gzip压缩"></a>开启Gzip压缩</h3><p>开启gzip压缩可以减少HTTP传输的数据量和时间，从而减少客户端请求的响应时间，由于降低了请求时间，页面的加载速度也会得到提升，会有更快的渲染速度，极大地改善了用户体验。由于现在基本上所有的主流浏览器都支持Gzip的压缩方式，只需要对服务器进行相关设置即可，这里就不具体讲如何配置服务器。</p><h3 id="压缩混淆代码"><a href="#压缩混淆代码" class="headerlink" title="压缩混淆代码"></a>压缩混淆代码</h3><p>我们平常也会对代码进行压缩混淆，可以通过<code>UglifyJS</code>等工具来对js代码进行压缩，同时可以去掉不必要的空格、注释、console信息等，也可以有效的减小代码体积。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文到这里就结束了，主要是对webpack的打包优化部分做了些讲解，当然能力和时间有限，只研究了部分方法，可能会有其他更多的优化方法，无论是从编译打包的体积还是速度上都能有更好的优化。接触了一段时间的webpack发现作为一个打包工具实在是过于复杂，无论从开始的官方文档还是到新的高级特性，都很难去完全掌握，还得需要自己不断去实践去深入研究才行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端的打包工具从之前的browserify、grunt、gulp到现如今的rollup、webpack，涌现出了很多优秀的打包工具，而目前最火的无疑是webpack，无论是当前热门的框架还是工具库很多都选择了它作为打包工具，因此在开发中webpack作为打包工具是一个很好的选择。在最近的项目开发中我也用到了webpack，其中也碰到了不少优化方面的问题，这里总结一下webpack打包优化的一些细节和方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS中的函数调用和this指向</title>
    <link href="http://arlendp.me/web/js/js-function-call-and-this-reference/"/>
    <id>http://arlendp.me/web/js/js-function-call-and-this-reference/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2018-04-15T11:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们平时写js的过程中，函数调用是一个很常见的操作。js中的函数调用方式常见的有几种，如直接调用、作为对象的方法调用、通过apply、call来调用等等。而在函数调用过程中，我们又常常会碰到this的指向问题，稍有不慎便会入坑。在这里，主要是对函数调用和this的指向进行一个总结。</p><a id="more"></a><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>在js中，函数调用通常有四种方式。</p><ul><li>作为函数直接调用</li><li>作为对象的方法调用</li><li>作为构造函数调用</li><li>通过apply、call调用</li></ul><h3 id="作为函数直接调用"><a href="#作为函数直接调用" class="headerlink" title="作为函数直接调用"></a>作为函数直接调用</h3><p>这种方式就是最常见的直接调用一个函数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'作为函数直接调用'</span>);</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>这种形式的函数调用就是最简单的调用，它不属于某个对象，不是对象调用的方式。但这种函数由于是全局的，所以会发生命名冲突的问题，因此需要注意。</p><h3 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h3><p>在js中大部分的操作都是对对象进行操作，所以将函数作为对象的方法来调用也是很常见的一种方式。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'作为对象的方法调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func();</span><br></pre></td></tr></table></figure><p>这里函数func是obj的一个方法，对象调用它的方法来调用了这个函数。</p><h3 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h3><p>通过new关键字来调用函数就是调用了构造函数，在js中通过调用构造函数来创建对象。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Func(<span class="string">'作为构造函数调用'</span>)</span><br></pre></td></tr></table></figure><h3 id="通过call、apply调用"><a href="#通过call、apply调用" class="headerlink" title="通过call、apply调用"></a>通过call、apply调用</h3><p>call和apply是函数预定义的方法，通过它们可以直接对函数进行调用，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">method, name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method + <span class="string">' '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">func.apply(<span class="literal">null</span>, [<span class="string">'apply'</span>, <span class="string">'调用函数'</span>]);</span><br><span class="line">func.call(<span class="literal">null</span>, <span class="string">'call'</span>, <span class="string">'调用函数'</span>);</span><br></pre></td></tr></table></figure><p>可见两种方式调用函数很类似，第一个参数会作为函数内部this的指向，后面的参数则作为函数的形参传入，唯一的区别在于参数的形式，apply调用时需要以数组的形式表示，而call调用需要用逗号分隔的形式。</p><p>函数调用的方法就是以上的四种，通过对函数的调用，我们会发现一些问题，比如在apply和call的调用上时，</p><p>第一个参数是什么意思，这就涉及到函数调用中常见的一个问题，this的指向。</p><h2 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h2><p>其实函数内部this的指向可以归纳为一句话：<strong>函数内this指向调用该函数的对象</strong>。我们以上面四种函数调用的方式来证明这句话。</p><p>首先是函数的直接调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'func'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure><p>根据<code>this</code>指向调用函数的对象这句话，这里由于函数是直接调用的，因此这里调用函数的对象是全局对象<code>window</code>，因此<code>this.name</code>就是<code>window.name</code>，<code>var name = &#39;window&#39;</code>这种全局声明的方式使得<code>name</code>会作为<code>window</code>对象的属性，因此这里打印的就是<code>window</code></p><p>接下来看函数作为对象的方法调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name: <span class="string">'obj'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func(); <span class="comment">// 'obj'</span></span><br></pre></td></tr></table></figure><p>在这里调用函数<code>func</code>的对象是<code>obj</code>，因此函数内部的<code>this</code>就指向<code>obj</code>，所以会打印<code>obj.name</code>的值，也就是<code>obj</code>。</p><p>这里有一个常见的坑，对代码进行微小的改动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name: <span class="string">'obj'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func_1 = obj.func;</span><br><span class="line">func_1(); <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure><p>这里可能会很奇怪，两次调用的方式看起来差不多，为何会得到不同的结果。其实仔细分析，还是根据那句总结的话来看，将<code>obj</code>中的<code>func</code>函数赋值给了<code>func_1</code>，此时<code>func_1</code>就是一个函数了，这里直接对它进行调用，实际上跟前面说的第一种调用方式直接调用相同，调用<code>func_1</code>的对象是<code>window</code>对象，因此这里打印的就是<code>window</code>。</p><p>接下来看函数作为构造函数时this的指向：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Func(<span class="string">'构造函数'</span>);</span><br></pre></td></tr></table></figure><p>这里的this指向的是通过<code>Func</code>构造生成的实例对象，这和前面的调用方式稍有不同。</p><p>那this的指向是否可以手动修改呢？答案是可以。前面提到的apply和call就可以实现这一点，同时还有其他的方法能达到这种效果。</p><h3 id="this指向的改变"><a href="#this指向的改变" class="headerlink" title="this指向的改变"></a>this指向的改变</h3><p>在有些情况下，我们需要对this的指向进行改变以达到我们想要的效果，在js中是有几种方式可以实现的。</p><h4 id="apply、call和bind方法"><a href="#apply、call和bind方法" class="headerlink" title="apply、call和bind方法"></a>apply、call和bind方法</h4><p>使用这三种方法都可以对函数中this的指向进行改变，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name: <span class="string">'obj'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func_1 = obj.func;</span><br><span class="line">func_1(); <span class="comment">// 'window'</span></span><br><span class="line">func_1.apply(obj); <span class="comment">// 'obj'</span></span><br><span class="line">func_1.call(obj); <span class="comment">// 'obj'</span></span><br><span class="line">func_1.bind(obj)(); <span class="comment">// 'obj'</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看出，对前面的例子稍作修改，通过这三种方式都可以将函数<code>func_1</code>中的<code>this</code>指向<code>obj</code>对象。</p><p>这三种方法间的区别在于，apply和call的第一个参数都是指定的this值，注意如果这里设置<code>this</code>为<code>null</code>或者<code>undefined</code>，在非严格模式下会自动指向全局对象，如果为原始值，则会指向该值的包装对象。apply的第二个参数则是一个包含函数参数的数组，call则是有多个参数。两者与<code>bind</code>方法的区别在于，<code>bind</code>方法会返回一个绑定了<code>this</code>指向的新的函数，因此需要手动调用来执行这个新的函数。</p><h3 id="es6箭头函数"><a href="#es6箭头函数" class="headerlink" title="es6箭头函数"></a>es6箭头函数</h3><p>在es6中提出的箭头函数便是为了解决js中函数this指向的各种问题，对于箭头函数，<strong>this始终指向函数定义时的this，而不是执行时的</strong>。箭头函数中并没有对this进行任何绑定，想要知道this的指向，必须查找作用域链才能知道其值。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func(); <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure><p>对于上述代码，根据函数内部的this指向的是调用函数的对象，但是这里通过<code>setTimeout</code>执行函数时并不知道是谁调用了这个匿名函数的，这里认为该函数是<code>window</code>对象调用的，因此打印的是<code>window</code>。</p><p>如果想对这里代码进行微小的调整来使其打印<code>obj</code>，可以按一下方式来修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func(); <span class="comment">// 'obj'</span></span><br></pre></td></tr></table></figure><p>这里箭头函数中的this指向的就是外层<code>func</code>函数内部的this指向，在调用<code>obj.func    ()</code>时可以得到函数<code>func</code>内部的<code>this</code>指向的是<code>obj</code>因此，箭头函数中的<code>this</code>指向的就是<code>obj</code>，因此得到上面的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>函数内部的this指向的是调用该函数的对象</li><li>构造函数中的this指向的是通过new该函数生成的实例对象</li><li>匿名函数自执行时this指向的是全局对象</li><li>可以通过apply、call和bind方法来改变函数this的指向</li><li>es6中的箭头函数中的this指向的是函数定义时的this，如果箭头函数被非箭头函数包裹，则箭头函数中this指向的是最近的非箭头函数的this对象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们平时写js的过程中，函数调用是一个很常见的操作。js中的函数调用方式常见的有几种，如直接调用、作为对象的方法调用、通过apply、call来调用等等。而在函数调用过程中，我们又常常会碰到this的指向问题，稍有不慎便会入坑。在这里，主要是对函数调用和this的指向进行一个总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>移动web开发中的viewport</title>
    <link href="http://arlendp.me/web/html/meta-viewport/"/>
    <id>http://arlendp.me/web/html/meta-viewport/</id>
    <published>2016-12-01T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.468Z</updated>
    
    <content type="html"><![CDATA[<p>在对移动端做响应式布局时，一般都是直接对meta标签进行设置，然后通过媒体查询来对不同尺寸的设备进行样式的调整。但是为什么meta标签要这么设置，以及它与视口(viewport)有什么关系一直不是很理解，因此花了一点时间对这个问题进行了整理，也对其有了更深入的了解。<br><a id="more"></a></p><h2 id="CSS中的像素和设备像素"><a href="#CSS中的像素和设备像素" class="headerlink" title="CSS中的像素和设备像素"></a>CSS中的像素和设备像素</h2><p>css中的像素理解起来很简单，就是我们在css文件中设置的像素值，如<code>width: 500px</code>。而设备像素就是电脑或者手机屏幕的物理像素，而css像素和设备像素又有什么关系呢，这就涉及到一个属性<code>devicePixelRatio</code>，它是window对象下的属性，可以直接通过<code>window.devicePixelRatio</code>来读取它。对于一般情况下这个值都是1，在retina屏上则是2。这个属性表示的是<strong>css中的一个像素对应的设备像素数</strong>，因此一般情况下，css中的一个像素就对应设备上的一个像素，只有在某些特殊的显示屏上才会有css的一个像素对应多个像素的情况。</p><h2 id="视口的概念"><a href="#视口的概念" class="headerlink" title="视口的概念"></a>视口的概念</h2><p>我们一般认为视口就是设备的可视区域，也就是用来显示网页的那一块区域。随着移动设备的出现，不同的设备可能有着不同的可视区域大小，具体可以通过<a href="http://viewportsizes.com/" target="_blank" rel="noopener">viewportsize</a>来查看，或者直接通过浏览器的开发工具来查看。</p><p>但在开发过程中会发现视口显示的像素并不是设备的可视区域的像素，举个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container-1</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#abccbb</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.contaienr-2</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#343421</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在iphone6的显示下效果如图：</p><p><img src="/static/images/viewport/1.png" alt="1"></p><p>这里会看到，当两个container的宽度适应屏幕大小时显示的是980px，而不是设备的375px。不同的设备下这个值也不同，主要大小有980和1024，可以通过<code>document.documentElement.clientWidth</code>来得到。而至于这里为什么和设备像素不同，又会涉及到以下meta标签中viewport的知识。</p><h2 id="meta标签中的viewport"><a href="#meta标签中的viewport" class="headerlink" title="meta标签中的viewport"></a>meta标签中的viewport</h2><p>在做移动端web开发时都会对这个值进行设置，一般会设置成<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale = 1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</code>。这样设置会使得viewport宽度等于设备的宽度并且同时不允许用户进行手势缩放。</p><p><img src="/static/images/viewport/2.png" alt="2"></p><p>这样再次查看上面这张图会发现它的视口宽度和设备宽度已经相等了。在开发过程中我们需要的就是这种效果。</p><p>在meta标签的viewport中，允许设置以下六种值：</p><ul><li>width：设置视口宽度，可以为具体的像素值或者是device-width</li><li>height：设置视口的高度，一般不使用</li><li>initial-scale：设置视口的初始缩放值</li><li>minimum-scale：设置视口最大缩放值</li><li>maximum-scale：设置视口最小缩放值</li><li>user-scalable：设置用户是否可以手势缩放</li></ul><p>因此这里可以看出，通过上面常用的meta viewport的设置可以使得视口宽度和设备宽度相等。这里要注意，<strong>initial-scale、minimum-scale和maximum-scale指的是设备大小和视口大小的比值</strong>。</p><p>现在来看图一的问题也就好理解了，iphone默认对视口进行了调整，即将视口调整到了980px，这里使用的是initial-scale来对其进行调整，可以计算出<code>375/980=0.38</code>即是这里的初始缩放值。</p><p>另一点需要注意的是既然width和user-scale都可以设置视口大小，那么两个同时使用则浏览器采用的是哪一个呢，经过测试最终效果使用的是两个中尺寸更大的那一个值。但两者有一个区别是：如果较大值是width，则无论设为多少，视口的大小就是这个值；但如果较大值是initial-scale，则视口的大小是有限制的，对于不同设备不全相同。</p><p>下面测试一下，不同情况下的显示效果：</p><p>css都设置为以下值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#abccbb</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#343421</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有设置meta viewport属性：</p><p><img src="/static/images/viewport/3.png" alt="3"></p><p>可以看到，元素完全显示在屏幕当中，无横向滑动框，即可视区域大小为1200px。但这里注意body的大小被限制在了980px。可见视口大小还是980px。因此可以认为<strong>meta viewport标签设置的尺寸就是视口大小，即文档尺寸大小</strong>。而此时屏幕大小则是由浏览器自动计算缩放值来使得网页不会出现滚动条来得到的。</p><p>设置meta viewport属性为<code>&lt;meta name=&#39;viewport&#39; content=&#39;width=1000, initial-scale=1.0&#39;&gt;</code>:</p><p><img src="/static/images/viewport/4.png" alt="4"></p><p>可以看到，文档宽度为1000px，超出屏幕宽度并出现滚动条。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从以上过程可以看出，css的像素和设备像素概念上是不同的，在移动设备上不同设备的尺寸也不尽相同。为了能在开发时对设备像素和css像素进行统一，我们会采用通过<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code>的方式来限制。对于width和initial-scale两个的区别，可以认为<strong>initial-scale设置了当前屏幕可视区域下可以显示的尺寸，width则设置了html元素尺寸</strong>。总的来说，在移动web开发中设置meta viewport则是为了让设备的视口大小和设备大小相等，从而方便通过根据不同设备的尺寸进行响应式设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对移动端做响应式布局时，一般都是直接对meta标签进行设置，然后通过媒体查询来对不同尺寸的设备进行样式的调整。但是为什么meta标签要这么设置，以及它与视口(viewport)有什么关系一直不是很理解，因此花了一点时间对这个问题进行了整理，也对其有了更深入的了解。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/HTML/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="http://arlendp.me/tags/CSS/"/>
    
      <category term="HTML" scheme="http://arlendp.me/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>js中几种位置和大小的理解</title>
    <link href="http://arlendp.me/web/js/js-size-and-position/"/>
    <id>http://arlendp.me/web/js/js-size-and-position/</id>
    <published>2016-11-19T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.467Z</updated>
    
    <content type="html"><![CDATA[<p>在js的计算过程中，经常会用到元素的各种位置和大小信息，js中提供了多种方法。本文总结了js中经常容易混淆的位置和大小的概念，如clientWidth、offsetLeft、scrollLeft等等。<br><a id="more"></a></p><h2 id="几种位置和宽高的理解"><a href="#几种位置和宽高的理解" class="headerlink" title="几种位置和宽高的理解"></a>几种位置和宽高的理解</h2><ul><li>js<ul><li>clientLeft（元素左边框宽度）、clientTop（元素上边框的宽度）、clientWidth（元素内容宽度加上左右两端padding宽度，行内元素为0）、clientHeight（元素内容宽度加上上下两端padding宽度，行内元素为0）</li><li>offsetParent<ul><li>对于非定位元素是其根元素（标准模式下是html，怪异模式下是body）</li><li>对于定位元素是其最近的定位父元素</li></ul></li><li>offsetLeft（元素的外padding到offsetParent的外padding的距离。对于inline元素则是从外border到offsetParent的外padding）、offsetTop、offsetWidth（包含元素的宽度、padding以及滚动条（元素宽度会留一部分给滚动条）、offsetHeight</li><li>scrollLeft（元素内容向右滚动的距离）、scrollTop（元素内容向下滚动的距离）、scrollWidth（元素内容宽度与元素本身宽度的较大值，本身宽度包括padding）、scrollHeight</li><li>getBoundingClientRect（元素的宽高：除了margin以外的宽高。元素的位置：除了margin外元素的左上角与视口的左上角的相对位置。对于可滚动的元素，其内容在滚动过程中坐标会变化）</li></ul></li><li>jquery<ul><li>position（相对于offset parent的位置）</li><li>scrollTop（与js中scrollTop相同）</li><li>width、height<ul><li>只包含内容宽度和高度，与<code>$().css(&#39;width&#39;)</code>返回的结果相同，只是类型是number，后者以’px’为单位。</li></ul></li><li>offset（相对于<code>docuemnt</code>的位置，与scrollLeft、scrollTop相同）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在js的计算过程中，经常会用到元素的各种位置和大小信息，js中提供了多种方法。本文总结了js中经常容易混淆的位置和大小的概念，如clientWidth、offsetLeft、scrollLeft等等。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Requests</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-requests/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-requests/</id>
    <published>2016-11-11T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.461Z</updated>
    
    <content type="html"><![CDATA[<p>文件的加载对于很多应用都格外重要，对d3来说也是如此。对于绘制结构简单、数据量不大的图形，尚且可以将数据和js代码存放在一起，但是对于数据结构复杂、数据量庞大的情况，数据集应该被单独存放于独立的文件中，因此这里就涉及到了文件的读取问题。该模块用于对原生的<code>XMLHttpRequest</code>进行封装，可用于加载文件。<br><a id="more"></a></p><h2 id="d3-request"><a href="#d3-request" class="headerlink" title="d3.request"></a>d3.request</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">// d3.request</span><br><span class="line">function request(url, callback) &#123;</span><br><span class="line">    var request,</span><br><span class="line">        event = dispatch(&quot;beforesend&quot;, &quot;progress&quot;, &quot;load&quot;, &quot;error&quot;),</span><br><span class="line">        mimeType,</span><br><span class="line">        headers = map$1(),</span><br><span class="line">        xhr = new XMLHttpRequest,</span><br><span class="line">        user = null,</span><br><span class="line">        password = null,</span><br><span class="line">        response,</span><br><span class="line">        responseType,</span><br><span class="line">        timeout = 0;</span><br><span class="line"></span><br><span class="line">    // 对于不支持跨域资源共享的IE浏览器，采用XDomainRequest</span><br><span class="line">    if (typeof XDomainRequest !== &quot;undefined&quot;</span><br><span class="line">        &amp;&amp; !(&quot;withCredentials&quot; in xhr)</span><br><span class="line">        &amp;&amp; /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;</span><br><span class="line">    //如果支持onload回调方法则绑定该方法，否则使用onreadystatechange方法</span><br><span class="line">    &quot;onload&quot; in xhr</span><br><span class="line">        //三种事件分别是请求成功完成、请求失败和请求时限到期未完成</span><br><span class="line">        ? xhr.onload = xhr.onerror = xhr.ontimeout = respond</span><br><span class="line">        : xhr.onreadystatechange = function(o) &#123; xhr.readyState &gt; 3 &amp;&amp; respond(o); &#125;;</span><br><span class="line"></span><br><span class="line">    function respond(o) &#123;</span><br><span class="line">      var status = xhr.status, result;</span><br><span class="line">      if (!status &amp;&amp; hasResponse(xhr)</span><br><span class="line">          || status &gt;= 200 &amp;&amp; status &lt; 300</span><br><span class="line">          || status === 304) &#123;</span><br><span class="line">        if (response) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            //先通过response函数对返回结果进行处理</span><br><span class="line">            result = response.call(request, xhr);</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            event.call(&quot;error&quot;, request, e);</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result = xhr;</span><br><span class="line">        &#125;</span><br><span class="line">        event.call(&quot;load&quot;, request, result);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        event.call(&quot;error&quot;, request, o);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.onprogress = function(e) &#123;</span><br><span class="line">      event.call(&quot;progress&quot;, request, e);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    request = &#123;</span><br><span class="line">      //设置请求头信息</span><br><span class="line">      header: function(name, value) &#123;</span><br><span class="line">        name = (name + &quot;&quot;).toLowerCase();</span><br><span class="line">        if (arguments.length &lt; 2) return headers.get(name);</span><br><span class="line">        if (value == null) headers.remove(name);</span><br><span class="line">        else headers.set(name, value + &quot;&quot;);</span><br><span class="line">        return request;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 设置服务器返回数据类型，用于accept请求头和overrideMimeType方法</span><br><span class="line">      mimeType: function(value) &#123;</span><br><span class="line">        if (!arguments.length) return mimeType;</span><br><span class="line">        mimeType = value == null ? null : value + &quot;&quot;;</span><br><span class="line">        return request;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      /* 指定返回值类型，可以为以下几种值：</span><br><span class="line">       * ”“：字符串（默认值）</span><br><span class="line">       * “arraybuffer”：ArrayBuffer对象</span><br><span class="line">       * “blob”：Blob对象</span><br><span class="line">       * “document”：Document对象</span><br><span class="line">       * “json”：JSON对象</span><br><span class="line">       * “text”：字符串</span><br><span class="line">       */</span><br><span class="line">      responseType: function(value) &#123;</span><br><span class="line">        if (!arguments.length) return responseType;</span><br><span class="line">        responseType = value;</span><br><span class="line">        return request;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      timeout: function(value) &#123;</span><br><span class="line">        if (!arguments.length) return timeout;</span><br><span class="line">        timeout = +value;</span><br><span class="line">        return request;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      user: function(value) &#123;</span><br><span class="line">        return arguments.length &lt; 1 ? user : (user = value == null ? null : value + &quot;&quot;, request);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      password: function(value) &#123;</span><br><span class="line">        return arguments.length &lt; 1 ? password : (password = value == null ? null : value + &quot;&quot;, request);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      //将返回内容转化成指定类型</span><br><span class="line">      response: function(value) &#123;</span><br><span class="line">        response = value;</span><br><span class="line">        return request;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 使用GET方法发送请求</span><br><span class="line">      get: function(data, callback) &#123;</span><br><span class="line">        return request.send(&quot;GET&quot;, data, callback);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 使用POST方法发送请求</span><br><span class="line">      post: function(data, callback) &#123;</span><br><span class="line">        return request.send(&quot;POST&quot;, data, callback);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 修改请求头信息，设置服务器返回数据类型，监听error和load事件并设置回调函数</span><br><span class="line">      send: function(method, data, callback) &#123;</span><br><span class="line">        xhr.open(method, url, true, user, password);</span><br><span class="line">        if (mimeType != null &amp;&amp; !headers.has(&quot;accept&quot;)) headers.set(&quot;accept&quot;, mimeType + &quot;,*/*&quot;);</span><br><span class="line">        //设置请求头</span><br><span class="line">        if (xhr.setRequestHeader) headers.each(function(value, name) &#123; xhr.setRequestHeader(name, value); &#125;);</span><br><span class="line">        //指定服务器返回数据类型</span><br><span class="line">        if (mimeType != null &amp;&amp; xhr.overrideMimeType) xhr.overrideMimeType(mimeType);</span><br><span class="line">        if (responseType != null) xhr.responseType = responseType;</span><br><span class="line">        if (timeout &gt; 0) xhr.timeout = timeout;</span><br><span class="line">        if (callback == null &amp;&amp; typeof data === &quot;function&quot;) callback = data, data = null;</span><br><span class="line">        if (callback != null &amp;&amp; callback.length === 1) callback = fixCallback(callback);</span><br><span class="line">        if (callback != null) request.on(&quot;error&quot;, callback).on(&quot;load&quot;, function(xhr) &#123; callback(null, xhr); &#125;);</span><br><span class="line">        //调用beforesend监听事件</span><br><span class="line">        event.call(&quot;beforesend&quot;, request, xhr);</span><br><span class="line">        //发送请求</span><br><span class="line">        xhr.send(data == null ? null : data);</span><br><span class="line">        return request;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      abort: function() &#123;</span><br><span class="line">        xhr.abort();</span><br><span class="line">        return request;</span><br><span class="line">      &#125;,</span><br><span class="line">      //设置事件监听函数，只能是以下类型：beforesend、progress、load和error</span><br><span class="line">      on: function() &#123;</span><br><span class="line">        var value = event.on.apply(event, arguments);</span><br><span class="line">        return value === event ? request : value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //如果callback参数被传入，则会立即将请求发送出去，若没有传入callback则可继续配置request</span><br><span class="line">    if (callback != null) &#123;</span><br><span class="line">      if (typeof callback !== &quot;function&quot;) throw new Error(&quot;invalid callback: &quot; + callback);</span><br><span class="line">      return request.get(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d3-csv"><a href="#d3-csv" class="headerlink" title="d3.csv"></a>d3.csv</h2><p>用于读取指定URL中的csv文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//d3.csv</span><br><span class="line">var csv$1 = dsv$1(&quot;text/csv&quot;, csvParse);</span><br><span class="line"></span><br><span class="line">function dsv$1(defaultMimeType, parse) &#123;</span><br><span class="line">    return function(url, row, callback) &#123;</span><br><span class="line">      //可以省略row函数</span><br><span class="line">      if (arguments.length &lt; 3) callback = row, row = null;</span><br><span class="line">      var r = request(url).mimeType(defaultMimeType);</span><br><span class="line">      //设置row函数</span><br><span class="line">      r.row = function(_) &#123; return arguments.length ? r.response(responseOf(parse, row = _)) : row; &#125;;</span><br><span class="line">      r.row(row);</span><br><span class="line">      return callback ? r.get(callback) : r;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//返回解析函数</span><br><span class="line">function responseOf(parse, row) &#123;</span><br><span class="line">    return function(request) &#123;</span><br><span class="line">      return parse(request.responseText, row);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分是直接调用request方法来读取文件，修改了服务器返回数据类型和response方法。与以下方法等同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d3.request(url)</span><br><span class="line">    .mimeType(&quot;text/csv&quot;)</span><br><span class="line">    .response(function(xhr) &#123; return d3.csvParse(xhr.responseText, row); &#125;)</span><br><span class="line">    .get(callback);</span><br></pre></td></tr></table></figure></p><h2 id="d3-html"><a href="#d3-html" class="headerlink" title="d3.html"></a>d3.html</h2><p>用于读取HTML文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var html = type(&quot;text/html&quot;, function(xhr) &#123;</span><br><span class="line">    return document.createRange().createContextualFragment(xhr.responseText);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>将返回的字符串构造成document fragment，形成一个DOM节点可以对其进行操作。</p><h2 id="d3-json"><a href="#d3-json" class="headerlink" title="d3.json"></a>d3.json</h2><p>读取JSON文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//d3.json</span><br><span class="line">var json = type(&quot;application/json&quot;, function(xhr) &#123;</span><br><span class="line">    return JSON.parse(xhr.responseText);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>通过<code>JSON.parse</code>方法对返回的字符串进行处理，转化成json格式的数据。</p><h2 id="d3-tsv"><a href="#d3-tsv" class="headerlink" title="d3.tsv"></a>d3.tsv</h2><p>用于读取tsv文件，和上述<code>d3.csv</code>类似。<br>等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d3.request(url)</span><br><span class="line">    .mimeType(&quot;text/tab-separated-values&quot;)</span><br><span class="line">    .response(function(xhr) &#123; return d3.tsvParse(xhr.responseText, row); &#125;)</span><br><span class="line">    .get(callback);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件的加载对于很多应用都格外重要，对d3来说也是如此。对于绘制结构简单、数据量不大的图形，尚且可以将数据和js代码存放在一起，但是对于数据结构复杂、数据量庞大的情况，数据集应该被单独存放于独立的文件中，因此这里就涉及到了文件的读取问题。该模块用于对原生的&lt;code&gt;XMLHttpRequest&lt;/code&gt;进行封装，可用于加载文件。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Dispatches</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-dispatches/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-dispatches/</id>
    <published>2016-10-29T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.460Z</updated>
    
    <content type="html"><![CDATA[<p>d3的dispatch模块是对原生事件处理的封装，通过该模块可以注册自定义的事件并绑定回调函数。<br><a id="more"></a></p><h2 id="d3-dispatch"><a href="#d3-dispatch" class="headerlink" title="d3.dispatch"></a>d3.dispatch</h2><p>该模块用于注册自定义名称的回调函数，并且可以调用这些函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function dispatch() &#123;</span><br><span class="line">    /*将传入的参数作为键值存入Dispatch对象中，参数以数组的形式传入并且不能有重复的元素</span><br><span class="line">     *初始化时参数只包含类型，不应包含名称，并入初始化时可以传入[&apos;click&apos;, &apos;drag&apos;]，在之后调用on方法时可以通过on(&apos;click.my1 drag.my2 hover&apos;, callback)这种方式来绑定回调函数</span><br><span class="line">     *在dispatch中是以如下方式存储：</span><br><span class="line">     *</span><br><span class="line">     *  &#123;</span><br><span class="line">     *    &apos;click&apos;: [</span><br><span class="line">     *      &#123;</span><br><span class="line">     *        name: &apos;my1&apos;,</span><br><span class="line">     *        value: callback</span><br><span class="line">     *      &#125;</span><br><span class="line">     *    ],</span><br><span class="line">     *    &apos;drag&apos;: [</span><br><span class="line">     *      &#123;</span><br><span class="line">     *        name: &apos;my2&apos;,</span><br><span class="line">     *        value: callback</span><br><span class="line">     *      &#125;</span><br><span class="line">     *    ],</span><br><span class="line">     *    &apos;hover&apos;: [</span><br><span class="line">     *      &#123;</span><br><span class="line">     *        name: &apos;&apos;,</span><br><span class="line">     *        value: callback</span><br><span class="line">     *      &#125;</span><br><span class="line">     *    ]</span><br><span class="line">     *  &#125;</span><br><span class="line">     */</span><br><span class="line">    for (var i = 0, n = arguments.length, _ = &#123;&#125;, t; i &lt; n; ++i) &#123;</span><br><span class="line">        if (!(t = arguments[i] + &quot;&quot;) || (t in _)) throw new Error(&quot;illegal type: &quot; + t);</span><br><span class="line">        _[t] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Dispatch(_);</span><br><span class="line">&#125;</span><br><span class="line">//Dispatch构造函数</span><br><span class="line">function Dispatch(_) &#123;</span><br><span class="line">    this._ = _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将传入的事件类型存入dispatch对象中。</p><h3 id="dispatch-on-typenames-callback"><a href="#dispatch-on-typenames-callback" class="headerlink" title="dispatch.on(typenames[, callback])"></a>dispatch.on(typenames[, callback])</h3><p>用于将事件和回调函数进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//绑定事件类型和回调函数</span><br><span class="line">  on: function(typename, callback) &#123;</span><br><span class="line">      var _ = this._,</span><br><span class="line">          T = parseTypenames(typename + &quot;&quot;, _),</span><br><span class="line">          t,</span><br><span class="line">          i = -1,</span><br><span class="line">          n = T.length;</span><br><span class="line"></span><br><span class="line">      // 如果没有callback参数，则返回以指定type和name注册的callback函数。</span><br><span class="line">      if (arguments.length &lt; 2) &#123;</span><br><span class="line">        while (++i &lt; n) if ((t = (typename = T[i]).type) &amp;&amp; (t = get(_[t], typename.name))) return t;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如果传入了callback函数，则对指定的type和name设置该回调函数。</span><br><span class="line">      // 如果callback为null，则可以移除指定的回调函数</span><br><span class="line">      if (callback != null &amp;&amp; typeof callback !== &quot;function&quot;) throw new Error(&quot;invalid callback: &quot; + callback);</span><br><span class="line">      while (++i &lt; n) &#123;</span><br><span class="line">        if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);</span><br><span class="line">        else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return this;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  //获取回调函数</span><br><span class="line">  function get(type, name) &#123;</span><br><span class="line">    for (var i = 0, n = type.length, c; i &lt; n; ++i) &#123;</span><br><span class="line">      if ((c = type[i]).name === name) &#123;</span><br><span class="line">        return c.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //设置回调函数</span><br><span class="line">  function set$1(type, name, callback) &#123;</span><br><span class="line">    for (var i = 0, n = type.length; i &lt; n; ++i) &#123;</span><br><span class="line">      if (type[i].name === name) &#123;</span><br><span class="line">        //如果type中已有指定的name，则将其从type数组中移除</span><br><span class="line">        type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (callback != null) type.push(&#123;name: name, value: callback&#125;);</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>其他方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//对dispatch进行拷贝，对拷贝后的内容进行修改不会影响之前的内容</span><br><span class="line">copy: function() &#123;</span><br><span class="line">    var copy = &#123;&#125;, _ = this._;</span><br><span class="line">    for (var t in _) copy[t] = _[t].slice();</span><br><span class="line">    return new Dispatch(copy);</span><br><span class="line">&#125;,</span><br><span class="line">call: function(type, that) &#123;</span><br><span class="line">    //第二个参数之后的参数会传入callback函数中</span><br><span class="line">    if ((n = arguments.length - 2) &gt; 0) for (var args = new Array(n), i = 0, n, t; i &lt; n; ++i) args[i] = arguments[i + 2];</span><br><span class="line">    if (!this._.hasOwnProperty(type)) throw new Error(&quot;unknown type: &quot; + type);</span><br><span class="line">    //会调用type下的所有回调函数</span><br><span class="line">    for (t = this._[type], i = 0, n = t.length; i &lt; n; ++i) t[i].value.apply(that, args);</span><br><span class="line">&#125;,</span><br><span class="line">apply: function(type, that, args) &#123;</span><br><span class="line">    if (!this._.hasOwnProperty(type)) throw new Error(&quot;unknown type: &quot; + type);</span><br><span class="line">    for (var t = this._[type], i = 0, n = t.length; i &lt; n; ++i) t[i].value.apply(that, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;d3的dispatch模块是对原生事件处理的封装，通过该模块可以注册自定义的事件并绑定回调函数。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Hierarchies</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-hierarchies/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-hierarchies/</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.461Z</updated>
    
    <content type="html"><![CDATA[<p>d3的hierarchy模块用于层级图的计算，会将输入的数据计算并转换成指定的层级格式提供给开发者使用。为了表示这种数据间的层级关系，该模块在内部使用了四叉树这种数据结构。<br><a id="more"></a></p><h2 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h2><p>用于计算层级数据，在层级图中使用。</p><h3 id="d3-hierarchy"><a href="#d3-hierarchy" class="headerlink" title="d3.hierarchy"></a>d3.hierarchy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 处理层级数据</span><br><span class="line">   * @param  &#123;object&#125; data     输入的数据</span><br><span class="line">   * @param  &#123;function&#125; children 用于获取data中的children数据的函数</span><br><span class="line">   * @return &#123;object&#125;          处理后的层级数据</span><br><span class="line">   */</span><br><span class="line">function hierarchy(data, children) &#123;</span><br><span class="line">    var root = new Node(data),</span><br><span class="line">        valued = +data.value &amp;&amp; (root.value = data.value),</span><br><span class="line">        node,</span><br><span class="line">        nodes = [root],</span><br><span class="line">        child,</span><br><span class="line">        childs,</span><br><span class="line">        i,</span><br><span class="line">        n;</span><br><span class="line"></span><br><span class="line">    if (children == null) children = defaultChildren;</span><br><span class="line">    //先处理父节点，后处理子节点，构造成node对象</span><br><span class="line">    while (node = nodes.pop()) &#123;</span><br><span class="line">      if (valued) node.value = +node.data.value;</span><br><span class="line">      if ((childs = children(node.data)) &amp;&amp; (n = childs.length)) &#123;</span><br><span class="line">        node.children = new Array(n);</span><br><span class="line">        for (i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">          nodes.push(child = node.children[i] = new Node(childs[i]));</span><br><span class="line">          child.parent = node;</span><br><span class="line">          child.depth = node.depth + 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root.eachBefore(computeHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>node用于表示hierarchy中的节点对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* node构造函数</span><br><span class="line">   * data: 该node相关联的数据</span><br><span class="line">   * depth: 该节点所在的层级数，根节点为0，子节点逐渐递增</span><br><span class="line">   * height: 该节点与其最远的子节点之间的距离，叶子节点为0</span><br><span class="line">   * parent: 该节点的父节点</span><br><span class="line">   */</span><br><span class="line">function Node(data) &#123;</span><br><span class="line">    this.data = data;</span><br><span class="line">    this.depth =</span><br><span class="line">    this.height = 0;</span><br><span class="line">    this.parent = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>node的原型方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//返回当前节点的所有父级节点，以当前节点开始逐级向上查找直至根节点</span><br><span class="line">  function node_ancestors() &#123;</span><br><span class="line">    var node = this, nodes = [node];</span><br><span class="line">    while (node = node.parent) &#123;</span><br><span class="line">      nodes.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    return nodes;</span><br><span class="line">  &#125;</span><br><span class="line">  //返回当前节点的所有子节点，包括当前节点</span><br><span class="line">  function node_descendants() &#123;</span><br><span class="line">    var nodes = [];</span><br><span class="line">    this.each(function(node) &#123;</span><br><span class="line">      nodes.push(node);</span><br><span class="line">    &#125;);</span><br><span class="line">    return nodes;</span><br><span class="line">  &#125;</span><br><span class="line">  //返回当前节点包含的所有叶子节点</span><br><span class="line">  function node_leaves() &#123;</span><br><span class="line">    var leaves = [];</span><br><span class="line">    this.eachBefore(function(node) &#123;</span><br><span class="line">      if (!node.children) &#123;</span><br><span class="line">        leaves.push(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return leaves;</span><br><span class="line">  &#125;</span><br><span class="line">  //以节点的父节点和本身构成一个新的对象，返回包含所有该种对象的数组</span><br><span class="line">  function node_links() &#123;</span><br><span class="line">    var root = this, links = [];</span><br><span class="line">    root.each(function(node) &#123;</span><br><span class="line">      if (node !== root) &#123; // Don’t include the root’s parent, if any.</span><br><span class="line">        links.push(&#123;source: node.parent, target: node&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return links;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>根据node的不同的遍历方式而有不同的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//广度优先？？？</span><br><span class="line">  function node_each(callback) &#123;</span><br><span class="line">    var node = this, current, next = [node], children, i, n;</span><br><span class="line">    do &#123;</span><br><span class="line">      current = next.reverse(), next = [];</span><br><span class="line">      while (node = current.pop()) &#123;</span><br><span class="line">        callback(node), children = node.children;</span><br><span class="line">        if (children) for (i = 0, n = children.length; i &lt; n; ++i) &#123;</span><br><span class="line">          next.push(children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; while (next.length);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  // 先处理回调函数，后访问子节点</span><br><span class="line">  function node_eachBefore(callback) &#123;</span><br><span class="line">    var node = this, nodes = [node], children, i;</span><br><span class="line">    while (node = nodes.pop()) &#123;</span><br><span class="line">      callback(node), children = node.children;</span><br><span class="line">      if (children) for (i = children.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        nodes.push(children[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  //先访问所有节点，之后逐个执行回调</span><br><span class="line">  function node_eachAfter(callback) &#123;</span><br><span class="line">    var node = this, nodes = [node], next = [], children, i, n;</span><br><span class="line">    while (node = nodes.pop()) &#123;</span><br><span class="line">      next.push(node), children = node.children;</span><br><span class="line">      if (children) for (i = 0, n = children.length; i &lt; n; ++i) &#123;</span><br><span class="line">        nodes.push(children[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (node = next.pop()) &#123;</span><br><span class="line">      callback(node);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>而在这些遍历方法的基础上构造出来的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//通过value函数对每个节点的data进行计算，节点的value值为其自己的value值加上所有子节点的value值之和。</span><br><span class="line">  function node_sum(value) &#123;</span><br><span class="line">    return this.eachAfter(function(node) &#123;</span><br><span class="line">      var sum = +value(node.data) || 0,</span><br><span class="line">          children = node.children,</span><br><span class="line">          i = children &amp;&amp; children.length;</span><br><span class="line">      while (--i &gt;= 0) sum += children[i].value;</span><br><span class="line">      node.value = sum;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //对所有节点的子节点进行排序，内部调用Array的原型链方法</span><br><span class="line">  function node_sort(compare) &#123;</span><br><span class="line">    return this.eachBefore(function(node) &#123;</span><br><span class="line">      if (node.children) &#123;</span><br><span class="line">        node.children.sort(compare);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //计算当前node到end的最短路径，返回的数组从当前节点的父节点开始到公共节点，然后到目标节点</span><br><span class="line">  function node_path(end) &#123;</span><br><span class="line">    var start = this,</span><br><span class="line">        ancestor = leastCommonAncestor(start, end),</span><br><span class="line">        nodes = [start];</span><br><span class="line">    //从start开始向上查找至ancestor</span><br><span class="line">    while (start !== ancestor) &#123;</span><br><span class="line">      start = start.parent;</span><br><span class="line">      nodes.push(start);</span><br><span class="line">    &#125;</span><br><span class="line">    var k = nodes.length;</span><br><span class="line">    while (end !== ancestor) &#123;</span><br><span class="line"></span><br><span class="line">      nodes.splice(k, 0, end);</span><br><span class="line">      end = end.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    return nodes;</span><br><span class="line">  &#125;</span><br><span class="line">  //返回最近的相同的祖先节点</span><br><span class="line">  function leastCommonAncestor(a, b) &#123;</span><br><span class="line">    if (a === b) return a;</span><br><span class="line">    var aNodes = a.ancestors(),</span><br><span class="line">        bNodes = b.ancestors(),</span><br><span class="line">        c = null;</span><br><span class="line">    a = aNodes.pop();</span><br><span class="line">    b = bNodes.pop();</span><br><span class="line">    while (a === b) &#123;</span><br><span class="line">      c = a;</span><br><span class="line">      a = aNodes.pop();</span><br><span class="line">      b = bNodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">  //复制一份相同的node</span><br><span class="line">  function node_copy() &#123;</span><br><span class="line">    return hierarchy(this).eachBefore(copyData);</span><br><span class="line">  &#125;</span><br><span class="line">  function copyData(node) &#123;</span><br><span class="line">    node.data = node.data.data;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Stratify"><a href="#Stratify" class="headerlink" title="Stratify"></a>Stratify</h2><p>将数据转化为层级形式。若数据格式已经是如下形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">        &quot;name&quot;: &quot;中国&quot;,</span><br><span class="line">        &quot;children&quot;: [&#123;</span><br><span class="line">                &quot;name&quot;: &quot;浙江&quot;,</span><br><span class="line">                &quot;children&quot;: [&#123;</span><br><span class="line">                    &quot;name&quot;: &quot;杭州&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;宁波&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;温州&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;绍兴&quot;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;广西&quot;,</span><br><span class="line">                &quot;children&quot;: [&#123;</span><br><span class="line">                    &quot;name&quot;: &quot;桂林&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;南宁&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;柳州&quot;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    &quot;name&quot;: &quot;防城港&quot;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;]</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>则可以直接传入上述<code>d3.hierarchy</code>方法来构造层级数据。若不是则用<code>d3.stratify</code>方法来处理，其关键部分是’id’和’parentId’方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//d3.stratify</span><br><span class="line">function stratify() &#123;</span><br><span class="line">    var id = defaultId,</span><br><span class="line">        parentId = defaultParentId;</span><br><span class="line"></span><br><span class="line">    function stratify(data) &#123;</span><br><span class="line">      var d,</span><br><span class="line">          i,</span><br><span class="line">          n = data.length,</span><br><span class="line">          root,</span><br><span class="line">          parent,</span><br><span class="line">          node,</span><br><span class="line">          nodes = new Array(n),</span><br><span class="line">          nodeId,</span><br><span class="line">          nodeKey,</span><br><span class="line">          nodeByKey = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        //将data中每个数据构造成node对象</span><br><span class="line">        d = data[i], node = nodes[i] = new Node(d);</span><br><span class="line">        //根据id函数获取data的id</span><br><span class="line">        if ((nodeId = id(d, i, data)) != null &amp;&amp; (nodeId += &quot;&quot;)) &#123;</span><br><span class="line">          nodeKey = keyPrefix$1 + (node.id = nodeId);</span><br><span class="line">          nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        node = nodes[i], nodeId = parentId(data[i], i, data);</span><br><span class="line">        //parentId为空时认为该node为根节点，但只能存在一个parentId为空的节点</span><br><span class="line">        if (nodeId == null || !(nodeId += &quot;&quot;)) &#123;</span><br><span class="line">          if (root) throw new Error(&quot;multiple roots&quot;);</span><br><span class="line">          root = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          parent = nodeByKey[keyPrefix$1 + nodeId];</span><br><span class="line">          //如果记录中没有parentId，则抛出异常</span><br><span class="line">          if (!parent) throw new Error(&quot;missing: &quot; + nodeId);</span><br><span class="line">          if (parent === ambiguous) throw new Error(&quot;ambiguous: &quot; + nodeId);</span><br><span class="line">          //将该节点添加至parentId对应节点的children属性中</span><br><span class="line">          if (parent.children) parent.children.push(node);</span><br><span class="line">          else parent.children = [node];</span><br><span class="line">          //为node节点添加parent属性</span><br><span class="line">          node.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!root) throw new Error(&quot;no root&quot;);</span><br><span class="line">      root.parent = preroot;</span><br><span class="line">      //计算节点的depth和height值</span><br><span class="line">      root.eachBefore(function(node) &#123; node.depth = node.parent.depth + 1; --n; &#125;).eachBefore(computeHeight);</span><br><span class="line">      root.parent = null;</span><br><span class="line">      if (n &gt; 0) throw new Error(&quot;cycle&quot;);</span><br><span class="line"></span><br><span class="line">      return root;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置获取id的函数</span><br><span class="line">    stratify.id = function(x) &#123;</span><br><span class="line">      return arguments.length ? (id = required(x), stratify) : id;</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置获取父节点id的函数</span><br><span class="line">    stratify.parentId = function(x) &#123;</span><br><span class="line">      return arguments.length ? (parentId = required(x), stratify) : parentId;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return stratify;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>用于绘制集群图，它会将所有的叶子节点放置在相同的深度，即所有的叶子节点会对齐。这里返回的结果包含(x, y)坐标，即可以直接用于绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//d3.cluster</span><br><span class="line">function cluster() &#123;</span><br><span class="line">    var separation = defaultSeparation,</span><br><span class="line">        dx = 1,</span><br><span class="line">        dy = 1,</span><br><span class="line">        nodeSize = false;</span><br><span class="line"></span><br><span class="line">    function cluster(root) &#123;</span><br><span class="line">      var previousNode,</span><br><span class="line">          x = 0;</span><br><span class="line"></span><br><span class="line">      root.eachAfter(function(node) &#123;</span><br><span class="line">        var children = node.children;</span><br><span class="line">        if (children) &#123;</span><br><span class="line">          //计算非叶子节点的x、y坐标，与其子节点相关</span><br><span class="line">          node.x = meanX(children);</span><br><span class="line">          node.y = maxY(children);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 如果是叶子节点，则其y坐标为0，x坐标则根据当前节点与前一个节点是否含有相同的父节点来设置</span><br><span class="line">          node.x = previousNode ? x += separation(node, previousNode) : 0;</span><br><span class="line">          node.y = 0;</span><br><span class="line">          previousNode = node;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      var left = leafLeft(root),</span><br><span class="line">          right = leafRight(root),</span><br><span class="line">          x0 = left.x - separation(left, right) / 2,</span><br><span class="line">          x1 = right.x + separation(right, left) / 2;</span><br><span class="line"></span><br><span class="line">      // 根据size大小对节点的x, y坐标进行调整</span><br><span class="line">      return root.eachAfter(nodeSize ? function(node) &#123;</span><br><span class="line">        //nodeSize为true时，将root放置于(0, 0)位置</span><br><span class="line">        node.x = (node.x - root.x) * dx;</span><br><span class="line">        node.y = (root.y - node.y) * dy;</span><br><span class="line">      &#125; : function(node) &#123;</span><br><span class="line">        //否则，按比例对节点坐标进行调整</span><br><span class="line">        node.x = (node.x - x0) / (x1 - x0) * dx;</span><br><span class="line">        node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    //separation用于将相邻的叶子节点进行分离</span><br><span class="line">    cluster.separation = function(x) &#123;</span><br><span class="line">      return arguments.length ? (separation = x, cluster) : separation;</span><br><span class="line">    &#125;;</span><br><span class="line">    //以数组的形式设置cluster的范围大小</span><br><span class="line">    cluster.size = function(x) &#123;</span><br><span class="line">      return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cluster.nodeSize = function(x) &#123;</span><br><span class="line">      return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p>用于产生树状布局，以根节点位置为基准，逐级对齐。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="Treemap"><a href="#Treemap" class="headerlink" title="Treemap"></a>Treemap</h2><p>用于产生矩形式树状结构图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">//d3.treemap</span><br><span class="line">function index$1() &#123;</span><br><span class="line">    var tile = squarify,</span><br><span class="line">        round = false,</span><br><span class="line">        dx = 1,</span><br><span class="line">        dy = 1,</span><br><span class="line">        paddingStack = [0],</span><br><span class="line">        paddingInner = constantZero,</span><br><span class="line">        paddingTop = constantZero,</span><br><span class="line">        paddingRight = constantZero,</span><br><span class="line">        paddingBottom = constantZero,</span><br><span class="line">        paddingLeft = constantZero;</span><br><span class="line"></span><br><span class="line">    function treemap(root) &#123;</span><br><span class="line">      root.x0 =</span><br><span class="line">      root.y0 = 0;</span><br><span class="line">      root.x1 = dx;</span><br><span class="line">      root.y1 = dy;</span><br><span class="line">      root.eachBefore(positionNode);</span><br><span class="line">      paddingStack = [0];</span><br><span class="line">      if (round) root.eachBefore(roundNode);</span><br><span class="line">      return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function positionNode(node) &#123;</span><br><span class="line">      var p = paddingStack[node.depth],</span><br><span class="line">          //将有效区域根据padding来缩小</span><br><span class="line">          x0 = node.x0 + p,</span><br><span class="line">          y0 = node.y0 + p,</span><br><span class="line">          x1 = node.x1 - p,</span><br><span class="line">          y1 = node.y1 - p;</span><br><span class="line">      //处理padding过大的情况</span><br><span class="line">      if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;</span><br><span class="line">      if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;</span><br><span class="line">      node.x0 = x0;</span><br><span class="line">      node.y0 = y0;</span><br><span class="line">      node.x1 = x1;</span><br><span class="line">      node.y1 = y1;</span><br><span class="line">      if (node.children) &#123;</span><br><span class="line">        p = paddingStack[node.depth + 1] = paddingInner(node) / 2;</span><br><span class="line">        //在调整了范围的基础上根据特定的padding再次进行调整</span><br><span class="line">        x0 += paddingLeft(node) - p;</span><br><span class="line">        y0 += paddingTop(node) - p;</span><br><span class="line">        x1 -= paddingRight(node) - p;</span><br><span class="line">        y1 -= paddingBottom(node) - p;</span><br><span class="line">        if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;</span><br><span class="line">        if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;</span><br><span class="line">        tile(node, x0, y0, x1, y1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    treemap.round = function(x) &#123;</span><br><span class="line">      return arguments.length ? (round = !!x, treemap) : round;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    treemap.size = function(x) &#123;</span><br><span class="line">      return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置tile函数，默认是d3.treemapSquarify，即按黄金分割比进行划分</span><br><span class="line">    treemap.tile = function(x) &#123;</span><br><span class="line">      return arguments.length ? (tile = required(x), treemap) : tile;</span><br><span class="line">    &#125;;</span><br><span class="line">    //同时设置paddingInner和paddingOuter</span><br><span class="line">    treemap.padding = function(x) &#123;</span><br><span class="line">      return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    treemap.paddingInner = function(x) &#123;</span><br><span class="line">      return arguments.length ? (paddingInner = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingInner;</span><br><span class="line">    &#125;;</span><br><span class="line">    //paddingOuter是由四个方向的padding构成</span><br><span class="line">    treemap.paddingOuter = function(x) &#123;</span><br><span class="line">      return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    treemap.paddingTop = function(x) &#123;</span><br><span class="line">      return arguments.length ? (paddingTop = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingTop;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    treemap.paddingRight = function(x) &#123;</span><br><span class="line">      return arguments.length ? (paddingRight = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingRight;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    treemap.paddingBottom = function(x) &#123;</span><br><span class="line">      return arguments.length ? (paddingBottom = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingBottom;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    treemap.paddingLeft = function(x) &#123;</span><br><span class="line">      return arguments.length ? (paddingLeft = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingLeft;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return treemap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>d3.treemap</code>中会对node进行区块划分，其中主要是用到<code>tile</code>函数来实现模块划分的逻辑，默认是<code>d3.treemapSquarify</code>即按黄金分割比进行区块的分割。</p><h3 id="d3-treemapSquarify"><a href="#d3-treemapSquarify" class="headerlink" title="d3.treemapSquarify"></a>d3.treemapSquarify</h3><p>通过黄金分割比来对treemap进行分割。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//黄金分割比</span><br><span class="line">var phi = (1 + Math.sqrt(5)) / 2;</span><br><span class="line">//按黄金分割比对treenode区块进行划分</span><br><span class="line">var squarify = (function custom(ratio) &#123;</span><br><span class="line"></span><br><span class="line">    function squarify(parent, x0, y0, x1, y1) &#123;</span><br><span class="line">      squarifyRatio(ratio, parent, x0, y0, x1, y1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    squarify.ratio = function(x) &#123;</span><br><span class="line">      return custom((x = +x) &gt; 1 ? x : 1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return squarify;</span><br><span class="line">&#125;)(phi);</span><br><span class="line"></span><br><span class="line">function squarifyRatio(ratio, parent, x0, y0, x1, y1) &#123;</span><br><span class="line">    var rows = [],</span><br><span class="line">        nodes = parent.children,</span><br><span class="line">        row,</span><br><span class="line">        nodeValue,</span><br><span class="line">        i0 = 0,</span><br><span class="line">        i1,</span><br><span class="line">        n = nodes.length,</span><br><span class="line">        dx, dy,</span><br><span class="line">        value = parent.value,</span><br><span class="line">        sumValue,</span><br><span class="line">        minValue,</span><br><span class="line">        maxValue,</span><br><span class="line">        newRatio,</span><br><span class="line">        minRatio,</span><br><span class="line">        alpha,</span><br><span class="line">        beta;</span><br><span class="line"></span><br><span class="line">    while (i0 &lt; n) &#123;</span><br><span class="line">      dx = x1 - x0, dy = y1 - y0;</span><br><span class="line">      minValue = maxValue = sumValue = nodes[i0].value;</span><br><span class="line">      //根据长宽比和黄金分割比计算alpha，其值不受子节点影响</span><br><span class="line">      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);</span><br><span class="line">      beta = sumValue * sumValue * alpha;</span><br><span class="line">      minRatio = Math.max(maxValue / beta, beta / minValue);</span><br><span class="line"></span><br><span class="line">      // 当ratio不增加时，添加node</span><br><span class="line">      for (i1 = i0 + 1; i1 &lt; n; ++i1) &#123;</span><br><span class="line">        sumValue += nodeValue = nodes[i1].value;</span><br><span class="line">        if (nodeValue &lt; minValue) minValue = nodeValue;</span><br><span class="line">        if (nodeValue &gt; maxValue) maxValue = nodeValue;</span><br><span class="line">        beta = sumValue * sumValue * alpha;</span><br><span class="line">        newRatio = Math.max(maxValue / beta, beta / minValue);</span><br><span class="line">        //不会添加使ratio增加的node，如果不满足退出循环</span><br><span class="line">        if (newRatio &gt; minRatio) &#123; sumValue -= nodeValue; break; &#125;</span><br><span class="line">        minRatio = newRatio;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 调整node的范围并确定分割的方向</span><br><span class="line">      rows.push(row = &#123;value: sumValue, dice: dx &lt; dy, children: nodes.slice(i0, i1)&#125;);</span><br><span class="line">      //当node区域长比宽短时</span><br><span class="line">      if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);</span><br><span class="line">      //当node区域宽比长短时</span><br><span class="line">      else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);</span><br><span class="line">      //value等于剩余未分配位置的node的value之和，i0也从未分配的node开始</span><br><span class="line">      value -= sumValue, i0 = i1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-treemapBinary"><a href="#d3-treemapBinary" class="headerlink" title="d3.treemapBinary"></a>d3.treemapBinary</h3><p>将treemap区域根据value值大致进行二等分，使两边的value值之和尽量相近。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//d3.treemapBinary</span><br><span class="line">function binary(parent, x0, y0, x1, y1) &#123;</span><br><span class="line">    var nodes = parent.children,</span><br><span class="line">        i, n = nodes.length,</span><br><span class="line">        sum, sums = new Array(n + 1);</span><br><span class="line"></span><br><span class="line">    for (sums[0] = sum = i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">      sums[i + 1] = sum += nodes[i].value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    partition(0, n, parent.value, x0, y0, x1, y1);</span><br><span class="line"></span><br><span class="line">    function partition(i, j, value, x0, y0, x1, y1) &#123;</span><br><span class="line">      if (i &gt;= j - 1) &#123;</span><br><span class="line">        var node = nodes[i];</span><br><span class="line">        node.x0 = x0, node.y0 = y0;</span><br><span class="line">        node.x1 = x1, node.y1 = y1;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var valueOffset = sums[i],</span><br><span class="line">          //加上前面的已经计算过的value值作为偏移量，这样才能将sums[mid]跟valueTarget进行比较</span><br><span class="line">          valueTarget = (value / 2) + valueOffset,</span><br><span class="line">          k = i + 1,</span><br><span class="line">          hi = j - 1;</span><br><span class="line">      //二分法查找</span><br><span class="line">      while (k &lt; hi) &#123;</span><br><span class="line">        var mid = k + hi &gt;&gt;&gt; 1;</span><br><span class="line">        if (sums[mid] &lt; valueTarget) k = mid + 1;</span><br><span class="line">        else hi = mid;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var valueLeft = sums[k] - valueOffset,</span><br><span class="line">          valueRight = value - valueLeft;</span><br><span class="line">      //当矩形较高时，进行上下分割</span><br><span class="line">      if ((y1 - y0) &gt; (x1 - x0)) &#123;</span><br><span class="line">        //根据左右的value和进行坐标划分</span><br><span class="line">        var yk = (y0 * valueRight + y1 * valueLeft) / value;</span><br><span class="line">        partition(i, k, valueLeft, x0, y0, x1, yk);</span><br><span class="line">        partition(k, j, valueRight, x0, yk, x1, y1);</span><br><span class="line">      &#125; </span><br><span class="line">      //否则进行左右分割</span><br><span class="line">      else &#123;</span><br><span class="line">        var xk = (x0 * valueRight + x1 * valueLeft) / value;</span><br><span class="line">        partition(i, k, valueLeft, x0, y0, xk, y1);</span><br><span class="line">        partition(k, j, valueRight, xk, y0, x1, y1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><p>节点以矩形区域的形式展现，节点间的相对位置可以看出其层级关系。同时区块的大小可以反映value值大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//d3.partition</span><br><span class="line">function partition() &#123;</span><br><span class="line">    var dx = 1,</span><br><span class="line">        dy = 1,</span><br><span class="line">        padding = 0,</span><br><span class="line">        round = false;</span><br><span class="line"></span><br><span class="line">    function partition(root) &#123;</span><br><span class="line">      var n = root.height + 1;</span><br><span class="line">      root.x0 =</span><br><span class="line">      root.y0 = padding;</span><br><span class="line">      root.x1 = dx;</span><br><span class="line">      root.y1 = dy / n;</span><br><span class="line">      root.eachBefore(positionNode(dy, n));</span><br><span class="line">      if (round) root.eachBefore(roundNode);</span><br><span class="line">      return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function positionNode(dy, n) &#123;</span><br><span class="line">      return function(node) &#123;</span><br><span class="line">        if (node.children) &#123;</span><br><span class="line">          treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);</span><br><span class="line">        &#125;</span><br><span class="line">        var x0 = node.x0,</span><br><span class="line">            y0 = node.y0,</span><br><span class="line">            //这里减去padding用于与下个兄弟节点分开</span><br><span class="line">            x1 = node.x1 - padding,</span><br><span class="line">            y1 = node.y1 - padding;</span><br><span class="line">        if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;</span><br><span class="line">        if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;</span><br><span class="line">        node.x0 = x0;</span><br><span class="line">        node.y0 = y0;</span><br><span class="line">        node.x1 = x1;</span><br><span class="line">        node.y1 = y1;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    partition.round = function(x) &#123;</span><br><span class="line">      return arguments.length ? (round = !!x, partition) : round;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    partition.size = function(x) &#123;</span><br><span class="line">      return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];</span><br><span class="line">    &#125;;</span><br><span class="line">    //padding用于将节点的相邻子节点分开</span><br><span class="line">    partition.padding = function(x) &#123;</span><br><span class="line">      return arguments.length ? (padding = +x, partition) : padding;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return partition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Pack"><a href="#Pack" class="headerlink" title="Pack"></a>Pack</h2><p>通过多个封闭圆来表现层级图。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;d3的hierarchy模块用于层级图的计算，会将输入的数据计算并转换成指定的层级格式提供给开发者使用。为了表示这种数据间的层级关系，该模块在内部使用了四叉树这种数据结构。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Quadtrees</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-quadtrees/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-quadtrees/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.461Z</updated>
    
    <content type="html"><![CDATA[<p>四叉树算法用于将二维空间划分成更多的矩形部分，将每个矩形划分成四个大小相等的区域，常用于碰撞检测算法，d3中的forceCollide、forceManyBody等都用到了该数据结构。<br><a id="more"></a></p><h2 id="d3-quadtree"><a href="#d3-quadtree" class="headerlink" title="d3.quadtree"></a>d3.quadtree</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * d3.quadtree用于生成四叉树</span><br><span class="line">   * @param  &#123;object&#125; nodes 将要添加到quadtree中的所有节点</span><br><span class="line">   * @param  &#123;function&#125; x     用于获取节点的x坐标的函数</span><br><span class="line">   * @param  &#123;function&#125; y     用于获取节点的y坐标的函数</span><br><span class="line">   * @return &#123;object&#125;       该quadtree对象</span><br><span class="line">   */</span><br><span class="line">function quadtree(nodes, x, y) &#123;</span><br><span class="line">    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);</span><br><span class="line">    return nodes == null ? tree : tree.addAll(nodes);</span><br><span class="line">&#125;</span><br><span class="line">  /**</span><br><span class="line">   * 四叉树的构造函数</span><br><span class="line">   * @param &#123;function&#125; x  获取x坐标</span><br><span class="line">   * @param &#123;function&#125; y  获取y坐标</span><br><span class="line">   * @param &#123;number&#125; x0 [x0, y0]到[x1, y1]为该quadtree的矩形区域的范围</span><br><span class="line">   * @param &#123;number&#125; y0 [x0, y0]到[x1, y1]为该quadtree的矩形区域的范围</span><br><span class="line">   * @param &#123;number&#125; x1 [x0, y0]到[x1, y1]为该quadtree的矩形区域的范围</span><br><span class="line">   * @param &#123;number&#125; y1 [x0, y0]到[x1, y1]为该quadtree的矩形区域的范围</span><br><span class="line">   */</span><br><span class="line">function Quadtree(x, y, x0, y0, x1, y1) &#123;</span><br><span class="line">    this._x = x;</span><br><span class="line">    this._y = y;</span><br><span class="line">    this._x0 = x0;</span><br><span class="line">    this._y0 = y0;</span><br><span class="line">    this._x1 = x1;</span><br><span class="line">    this._y1 = y1;</span><br><span class="line">    this._root = undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-add"><a href="#quadtree-add" class="headerlink" title="quadtree.add"></a>quadtree.add</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function tree_add(d) &#123;</span><br><span class="line">    var x = +this._x.call(null, d),</span><br><span class="line">        y = +this._y.call(null, d);</span><br><span class="line">    return add(this.cover(x, y), x, y, d);</span><br><span class="line">  &#125;</span><br><span class="line">  /* d3.quadtree的add方法，用于添加node</span><br><span class="line">   * add方法的执行流程如下：</span><br><span class="line">   * 1. 首次添加data0时，由于_root不存在，直接对其赋值data并返回。</span><br><span class="line">   * 2. 第二次添加data1时，node中此时是第一次添加的data0，执行do while循环，为_root赋值一个空数组。判断data1和data0是否是在一个象限(这里将一个区域划分成的四块叫做象限)，如果不在则根据索引分别添加至数组中；</span><br><span class="line">   * 如果在则对该象限再次划分四个区域，继续判断是否在同一个象限。</span><br><span class="line">   * 3. 之后每次添加data时，都会先查找该节点属于哪个象限，根据索引查找node，如果是数组则说明该区域有节点且已经再次划分了象限，则继续进入查找；如果是对象，则说明该区域只有一个节点，此时会对该区域进行划分执行步骤2中的过程；如果是undefined则直接插入该出。</span><br><span class="line">   * </span><br><span class="line">   */</span><br><span class="line">function add(tree, x, y, d) &#123;</span><br><span class="line">    if (isNaN(x) || isNaN(y)) return tree;</span><br><span class="line"></span><br><span class="line">    var parent,</span><br><span class="line">        node = tree._root,</span><br><span class="line">        leaf = &#123;data: d&#125;,</span><br><span class="line">        x0 = tree._x0,</span><br><span class="line">        y0 = tree._y0,</span><br><span class="line">        x1 = tree._x1,</span><br><span class="line">        y1 = tree._y1,</span><br><span class="line">        //(xm, ym)表示该区域的中心点</span><br><span class="line">        xm,</span><br><span class="line">        ym,</span><br><span class="line">        xp,</span><br><span class="line">        yp,</span><br><span class="line">        right,</span><br><span class="line">        bottom,</span><br><span class="line">        i,</span><br><span class="line">        j;</span><br><span class="line"></span><br><span class="line">    // 如果treenode当前不包含任何node，将leaf作为其节点</span><br><span class="line">    if (!node) return tree._root = leaf, tree;</span><br><span class="line"></span><br><span class="line">    // 看(x, y)是否和已有的点在一个象限中，若不是则直接插入，否则往下继续执行</span><br><span class="line">    while (node.length) &#123;</span><br><span class="line">      if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;</span><br><span class="line">      if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;</span><br><span class="line">      if (parent = node, !(node = node[i = bottom &lt;&lt; 1 | right])) return parent[i] = leaf, tree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断(x, y)是否已存在当前节点中</span><br><span class="line">    xp = +tree._x.call(null, node.data);</span><br><span class="line">    yp = +tree._y.call(null, node.data);</span><br><span class="line">    if (x === xp &amp;&amp; y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;</span><br><span class="line"></span><br><span class="line">    // 将当前区域进行划分，直至(x, y)和之前的节点不在同一个象限内</span><br><span class="line">    do &#123;</span><br><span class="line">      //parent = parent[i] = new Array(4)会为parent赋值一个空数组，但是由于node = parent，node会形成一个多维数组</span><br><span class="line">      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);</span><br><span class="line">      if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;</span><br><span class="line">      if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;</span><br><span class="line">    &#125; while ((i = bottom &lt;&lt; 1 | right) === (j = (yp &gt;= ym) &lt;&lt; 1 | (xp &gt;= xm)));</span><br><span class="line">    return parent[j] = node, parent[i] = leaf, tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-addAll"><a href="#quadtree-addAll" class="headerlink" title="quadtree.addAll"></a>quadtree.addAll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//d3.quadtree的addAll方法，先计算数据的范围调整quadtree，之后再添加数据</span><br><span class="line">function addAll(data) &#123;</span><br><span class="line">    var d, i, n = data.length,</span><br><span class="line">        x,</span><br><span class="line">        y,</span><br><span class="line">        xz = new Array(n),</span><br><span class="line">        yz = new Array(n),</span><br><span class="line">        x0 = Infinity,</span><br><span class="line">        y0 = Infinity,</span><br><span class="line">        x1 = -Infinity,</span><br><span class="line">        y1 = -Infinity;</span><br><span class="line"></span><br><span class="line">    // 根据_x和_y方法计算data值，得到x、y的范围[x0, x1]和[y0, y1]，即矩形区域的范围</span><br><span class="line">    for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">      // this._x和this._y是quadtree中定义的获取x、y坐标的方法</span><br><span class="line">      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;</span><br><span class="line">      xz[i] = x;</span><br><span class="line">      yz[i] = y;</span><br><span class="line">      if (x &lt; x0) x0 = x;</span><br><span class="line">      if (x &gt; x1) x1 = x;</span><br><span class="line">      if (y &lt; y0) y0 = y;</span><br><span class="line">      if (y &gt; y1) y1 = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无效点时的处理</span><br><span class="line">    if (x1 &lt; x0) x0 = this._x0, x1 = this._x1;</span><br><span class="line">    if (y1 &lt; y0) y0 = this._y0, y1 = this._y1;</span><br><span class="line"></span><br><span class="line">    // 为quadtree添加范围</span><br><span class="line">    this.cover(x0, y0).cover(x1, y1);</span><br><span class="line"></span><br><span class="line">    // 添加node</span><br><span class="line">    for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">      add(this, xz[i], yz[i], data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-cover"><a href="#quadtree-cover" class="headerlink" title="quadtree.cover"></a>quadtree.cover</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//为quadtree设置区域范围</span><br><span class="line">function tree_cover(x, y) &#123;</span><br><span class="line">    if (isNaN(x = +x) || isNaN(y = +y)) return this;</span><br><span class="line"></span><br><span class="line">    var x0 = this._x0,</span><br><span class="line">        y0 = this._y0,</span><br><span class="line">        x1 = this._x1,</span><br><span class="line">        y1 = this._y1;</span><br><span class="line"></span><br><span class="line">    // 如果该quadtree范围不存在，则根据当前的(x, y)坐标取范围</span><br><span class="line">    if (isNaN(x0)) &#123;</span><br><span class="line">      x1 = (x0 = Math.floor(x)) + 1;</span><br><span class="line">      y1 = (y0 = Math.floor(y)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果(x, y)在当前范围之外，则扩展当前范围</span><br><span class="line">    else if (x0 &gt; x || x &gt; x1 || y0 &gt; y || y &gt; y1) &#123;</span><br><span class="line">      var z = x1 - x0,</span><br><span class="line">          node = this._root,</span><br><span class="line">          parent,</span><br><span class="line">          i;</span><br><span class="line">      //将该矩形区域的中心看做坐标轴原点，根据x、y坐标轴划分成大小相等的四块区域，0表示右下方，1表示左下方，2表示右上方，3表示左上方。</span><br><span class="line">      //成倍的增长z，扩大当前范围直至(x, y)在当前区域内，在扩大范围的同时不断的构造node数组</span><br><span class="line">      switch (i = (y &lt; (y0 + y1) / 2) &lt;&lt; 1 | (x &lt; (x0 + x1) / 2)) &#123;</span><br><span class="line">        case 0: &#123;</span><br><span class="line">          do parent = new Array(4), parent[i] = node, node = parent;</span><br><span class="line">          while (z *= 2, x1 = x0 + z, y1 = y0 + z, x &gt; x1 || y &gt; y1);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 1: &#123;</span><br><span class="line">          do parent = new Array(4), parent[i] = node, node = parent;</span><br><span class="line">          while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 &gt; x || y &gt; y1);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 2: &#123;</span><br><span class="line">          do parent = new Array(4), parent[i] = node, node = parent;</span><br><span class="line">          while (z *= 2, x1 = x0 + z, y0 = y1 - z, x &gt; x1 || y0 &gt; y);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 3: &#123;</span><br><span class="line">          do parent = new Array(4), parent[i] = node, node = parent;</span><br><span class="line">          while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 &gt; x || y0 &gt; y);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (this._root &amp;&amp; this._root.length) this._root = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果(x, y)已经在当前范围内，则直接返回</span><br><span class="line">    else return this;</span><br><span class="line"></span><br><span class="line">    this._x0 = x0;</span><br><span class="line">    this._y0 = y0;</span><br><span class="line">    this._x1 = x1;</span><br><span class="line">    this._y1 = y1;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-extend"><a href="#quadtree-extend" class="headerlink" title="quadtree.extend"></a>quadtree.extend</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//若有参数且_ = [[x0, y0], [x1, y1]]用于通过cover方法设置quadtree的范围[x0, y0]和[x1, y1]；若没有参数，则以同样的数组形式返回当前区域的范围。</span><br><span class="line">function tree_extent(_) &#123;</span><br><span class="line">    return arguments.length</span><br><span class="line">        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])</span><br><span class="line">        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-data"><a href="#quadtree-data" class="headerlink" title="quadtree.data"></a>quadtree.data</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//返回quadtree中所有的node</span><br><span class="line">function tree_data() &#123;</span><br><span class="line">    var data = [];</span><br><span class="line">    this.visit(function(node) &#123;</span><br><span class="line">      if (!node.length) do data.push(node.data); while (node = node.next)</span><br><span class="line">    &#125;);</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-find"><a href="#quadtree-find" class="headerlink" title="quadtree.find"></a>quadtree.find</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//查找以(x, y)为中心，radius为半径的范围内离中心最近的点</span><br><span class="line">function tree_find(x, y, radius) &#123;</span><br><span class="line">    var data,</span><br><span class="line">      //(x0, y0)和(x3, y3)表示以(x, y)为中心的矩形搜索区域</span><br><span class="line">        x0 = this._x0,</span><br><span class="line">        y0 = this._y0,</span><br><span class="line">      //(x1, y1)和(x2, y2)表示当前node所在的区域范围</span><br><span class="line">        x1,</span><br><span class="line">        y1,</span><br><span class="line">        x2,</span><br><span class="line">        y2,</span><br><span class="line">        x3 = this._x1,</span><br><span class="line">        y3 = this._y1,</span><br><span class="line">        quads = [],</span><br><span class="line">        node = this._root,</span><br><span class="line">        q,</span><br><span class="line">        i;</span><br><span class="line"></span><br><span class="line">    if (node) quads.push(new Quad(node, x0, y0, x3, y3));</span><br><span class="line">    //若没有设置radius则默认为Infinity</span><br><span class="line">    if (radius == null) radius = Infinity;</span><br><span class="line">    else &#123;</span><br><span class="line">      x0 = x - radius, y0 = y - radius;</span><br><span class="line">      x3 = x + radius, y3 = y + radius;</span><br><span class="line">      radius *= radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (q = quads.pop()) &#123;</span><br><span class="line"></span><br><span class="line">      // 如果node不存在或者(x, y)在该node范围外则跳过执行</span><br><span class="line">      if (!(node = q.node)</span><br><span class="line">          //node所在区域与搜索区域不重叠</span><br><span class="line">          //</span><br><span class="line">          //</span><br><span class="line">          || (x1 = q.x0) &gt; x3</span><br><span class="line">          || (y1 = q.y0) &gt; y3</span><br><span class="line">          || (x2 = q.x1) &lt; x0</span><br><span class="line">          || (y2 = q.y1) &lt; y0) continue;</span><br><span class="line"></span><br><span class="line">      // 如果node为数组说明已对其进行了区域划分，开始递归查找</span><br><span class="line">      if (node.length) &#123;</span><br><span class="line">        var xm = (x1 + x2) / 2,</span><br><span class="line">            ym = (y1 + y2) / 2;</span><br><span class="line">        // node数组中0表示区域左上角，1表示右上角，2表示左下角，3表示右下角</span><br><span class="line">        quads.push(</span><br><span class="line">          new Quad(node[3], xm, ym, x2, y2),</span><br><span class="line">          new Quad(node[2], x1, ym, xm, y2),</span><br><span class="line">          new Quad(node[1], xm, y1, x2, ym),</span><br><span class="line">          new Quad(node[0], x1, y1, xm, ym)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 判断(x, y)所在的象限，并将该象限对应的node与栈顶的数据交换位置，如果是左上角区域及表示已是栈顶则不用处理</span><br><span class="line">        if (i = (y &gt;= ym) &lt;&lt; 1 | (x &gt;= xm)) &#123;</span><br><span class="line">          q = quads[quads.length - 1];</span><br><span class="line">          quads[quads.length - 1] = quads[quads.length - 1 - i];</span><br><span class="line">          quads[quads.length - 1 - i] = q;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 当查找到在搜索范围内的点后，缩小搜索范围</span><br><span class="line">      else &#123;</span><br><span class="line">        var dx = x - +this._x.call(null, node.data),</span><br><span class="line">            dy = y - +this._y.call(null, node.data),</span><br><span class="line">            d2 = dx * dx + dy * dy;</span><br><span class="line">        if (d2 &lt; radius) &#123;</span><br><span class="line">          var d = Math.sqrt(radius = d2);</span><br><span class="line">          x0 = x - d, y0 = y - d;</span><br><span class="line">          x3 = x + d, y3 = y + d;</span><br><span class="line">          data = node.data;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-remove"><a href="#quadtree-remove" class="headerlink" title="quadtree.remove"></a>quadtree.remove</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function tree_remove(d) &#123;</span><br><span class="line">    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; </span><br><span class="line"></span><br><span class="line">    var parent,</span><br><span class="line">        node = this._root,</span><br><span class="line">        retainer,</span><br><span class="line">        previous,</span><br><span class="line">        next,</span><br><span class="line">        x0 = this._x0,</span><br><span class="line">        y0 = this._y0,</span><br><span class="line">        x1 = this._x1,</span><br><span class="line">        y1 = this._y1,</span><br><span class="line">        x,</span><br><span class="line">        y,</span><br><span class="line">        xm,</span><br><span class="line">        ym,</span><br><span class="line">        right,</span><br><span class="line">        bottom,</span><br><span class="line">        i,</span><br><span class="line">        j;</span><br><span class="line"></span><br><span class="line">    if (!node) return this;</span><br><span class="line"></span><br><span class="line">    // 当node中有多个点时，进入查找</span><br><span class="line">    if (node.length) while (true) &#123;</span><br><span class="line">      //计算(x, y)所在的象限</span><br><span class="line">      if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;</span><br><span class="line">      if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;</span><br><span class="line">      //如果对应的象限中没有点，则说明查找不到该点，直接返回。</span><br><span class="line">      if (!(parent = node, node = node[i = bottom &lt;&lt; 1 | right])) return this;</span><br><span class="line">      //如果该象限只有一个点则跳出循环往下执行。</span><br><span class="line">      if (!node.length) break;</span><br><span class="line">      //</span><br><span class="line">      if (parent[(i + 1) &amp; 3] || parent[(i + 2) &amp; 3] || parent[(i + 3) &amp; 3]) retainer = parent, j = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // TODO: 这里存在一个问题，由于node.data和d都为数组，但是两个数据是不同的指针，因此这里不会相等</span><br><span class="line">    while (node.data !== d) if (!(previous = node, node = node.next)) return this;</span><br><span class="line">    if (next = node.next) delete node.next;</span><br><span class="line"></span><br><span class="line">    // If there are multiple coincident points, remove just the point.</span><br><span class="line">    if (previous) return (next ? previous.next = next : delete previous.next), this;</span><br><span class="line"></span><br><span class="line">    // If this is the root point, remove it.</span><br><span class="line">    if (!parent) return this._root = next, this;</span><br><span class="line"></span><br><span class="line">    // Remove this leaf.</span><br><span class="line">    next ? parent[i] = next : delete parent[i];</span><br><span class="line"></span><br><span class="line">    // If the parent now contains exactly one leaf, collapse superfluous parents.</span><br><span class="line">    if ((node = parent[0] || parent[1] || parent[2] || parent[3])</span><br><span class="line">        &amp;&amp; node === (parent[3] || parent[2] || parent[1] || parent[0])</span><br><span class="line">        &amp;&amp; !node.length) &#123;</span><br><span class="line">      if (retainer) retainer[j] = node;</span><br><span class="line">      else this._root = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-visit"><a href="#quadtree-visit" class="headerlink" title="quadtree.visit"></a>quadtree.visit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//采用先序遍历的方式，如果callback返回true，则执行不再访问其子节点；否则继续访问其子节点</span><br><span class="line">function tree_visit(callback) &#123;</span><br><span class="line">    var quads = [], q, node = this._root, child, x0, y0, x1, y1;</span><br><span class="line">    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));</span><br><span class="line">    while (q = quads.pop()) &#123;</span><br><span class="line">      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) &amp;&amp; node.length) &#123;</span><br><span class="line">        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;</span><br><span class="line">        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));</span><br><span class="line">        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));</span><br><span class="line">        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));</span><br><span class="line">        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-visitAfter"><a href="#quadtree-visitAfter" class="headerlink" title="quadtree.visitAfter"></a>quadtree.visitAfter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//采用后序遍历的方式，先将所有节点存入数组中，然后依次对所有节点进行操作。</span><br><span class="line">function tree_visitAfter(callback) &#123;</span><br><span class="line">    var quads = [], next = [], q;</span><br><span class="line">    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));</span><br><span class="line">    while (q = quads.pop()) &#123;</span><br><span class="line">      var node = q.node;</span><br><span class="line">      if (node.length) &#123;</span><br><span class="line">        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;</span><br><span class="line">        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));</span><br><span class="line">        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));</span><br><span class="line">        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));</span><br><span class="line">        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));</span><br><span class="line">      &#125;</span><br><span class="line">      next.push(q);</span><br><span class="line">    &#125;</span><br><span class="line">    while (q = next.pop()) &#123;</span><br><span class="line">      callback(q.node, q.x0, q.y0, q.x1, q.y1);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quadtree-copy"><a href="#quadtree-copy" class="headerlink" title="quadtree.copy"></a>quadtree.copy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//对quadtree进行复制，但是是通过引用来复制的而不是复制值。</span><br><span class="line">treeProto.copy = function() &#123;</span><br><span class="line">    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),</span><br><span class="line">        node = this._root,</span><br><span class="line">        nodes,</span><br><span class="line">        child;</span><br><span class="line"></span><br><span class="line">    if (!node) return copy;</span><br><span class="line"></span><br><span class="line">    if (!node.length) return copy._root = leaf_copy(node), copy;</span><br><span class="line"></span><br><span class="line">    nodes = [&#123;source: node, target: copy._root = new Array(4)&#125;];</span><br><span class="line">    while (node = nodes.pop()) &#123;</span><br><span class="line">      for (var i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">        if (child = node.source[i]) &#123;</span><br><span class="line">          if (child.length) nodes.push(&#123;source: child, target: node.target[i] = new Array(4)&#125;);</span><br><span class="line">          else node.target[i] = leaf_copy(child);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return copy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//复制叶子节点</span><br><span class="line">function leaf_copy(leaf) &#123;</span><br><span class="line">    var copy = &#123;data: leaf.data&#125;, next = copy;</span><br><span class="line">    while (leaf = leaf.next) next = next.next = &#123;data: leaf.data&#125;;</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad对象"><a href="#quad对象" class="headerlink" title="quad对象"></a>quad对象</h2><p>在quadtree的一些方法中使用到了quad对象用于存储quadtree中的node信息，包括node的值和其所在区域的坐标范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Quad构造函数</span><br><span class="line">   * @param &#123;object&#125; node 节点数据</span><br><span class="line">   * @param &#123;number&#125; x0   该节点的区域坐标范围</span><br><span class="line">   * @param &#123;number&#125; y0   该节点的区域坐标范围</span><br><span class="line">   * @param &#123;number&#125; x1   该节点的区域坐标范围</span><br><span class="line">   * @param &#123;number&#125; y1   该节点的区域坐标范围</span><br><span class="line">   *</span><br><span class="line">   * quad对象在quadtree的node中的位置如下：</span><br><span class="line">   * </span><br><span class="line">   *        |</span><br><span class="line">   *    0   |    1</span><br><span class="line">   *        |</span><br><span class="line">   * -------|--------</span><br><span class="line">   *        |</span><br><span class="line">   *    2   |    3</span><br><span class="line">   *        |</span><br><span class="line">   */</span><br><span class="line">function Quad(node, x0, y0, x1, y1) &#123;</span><br><span class="line">    this.node = node;</span><br><span class="line">    this.x0 = x0;</span><br><span class="line">    this.y0 = y0;</span><br><span class="line">    this.x1 = x1;</span><br><span class="line">    this.y1 = y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;四叉树算法用于将二维空间划分成更多的矩形部分，将每个矩形划分成四个大小相等的区域，常用于碰撞检测算法，d3中的forceCollide、forceManyBody等都用到了该数据结构。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Force</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-force/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-force/</id>
    <published>2016-09-28T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.461Z</updated>
    
    <content type="html"><![CDATA[<p>该模块用于模拟在粒子上的物理作用力，常用于网络图和层级图。<br><a id="more"></a></p><h2 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h2><h3 id="d3-forceSimulation"><a href="#d3-forceSimulation" class="headerlink" title="d3.forceSimulation"></a>d3.forceSimulation</h3><p>根据指定的nodes值创建一个新的simulation，此时还没有设置force函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">//d3.forceSimulation用于设置节点和相关参数</span><br><span class="line">function simulation(nodes) &#123;</span><br><span class="line">    var simulation,</span><br><span class="line">        //alpha表示simulation当前的状态</span><br><span class="line">        alpha = 1,</span><br><span class="line">        alphaMin = 0.001,</span><br><span class="line">        //alphaDecay表示alpha每次的衰减率</span><br><span class="line">        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),</span><br><span class="line">        //alphaTarget表示最终要稳定时的状态</span><br><span class="line">        alphaTarget = 0,</span><br><span class="line">        //velocityDecay表示速度的衰退率</span><br><span class="line">        velocityDecay = 0.6,</span><br><span class="line">        //用于存储force函数</span><br><span class="line">        forces = map$1(),</span><br><span class="line">        stepper = timer(step),</span><br><span class="line">        //simulation包含以下两种类型的事件</span><br><span class="line">        event = dispatch(&quot;tick&quot;, &quot;end&quot;);</span><br><span class="line"></span><br><span class="line">    if (nodes == null) nodes = [];</span><br><span class="line"></span><br><span class="line">    function step() &#123;</span><br><span class="line">      tick();</span><br><span class="line">      //自定义的tick函数，在这里被调用</span><br><span class="line">      event.call(&quot;tick&quot;, simulation);</span><br><span class="line">      //当alpha小于临界值即alphaMin时，停止计时</span><br><span class="line">      if (alpha &lt; alphaMin) &#123;</span><br><span class="line">        stepper.stop();</span><br><span class="line">        //自定义的end函数在这里调用</span><br><span class="line">        event.call(&quot;end&quot;, simulation);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function tick() &#123;</span><br><span class="line">      var i, n = nodes.length, node;</span><br><span class="line"></span><br><span class="line">      alpha += (alphaTarget - alpha) * alphaDecay;</span><br><span class="line">      //alpha用于force中对速度vx和vy进行设置</span><br><span class="line">      forces.each(function(force) &#123;</span><br><span class="line">        force(alpha);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        node = nodes[i];</span><br><span class="line">        //fx和fy是node的固定点，如果设置了该属性则node会固定在该位置</span><br><span class="line">        //这里简化了物理作用力，将当前位置坐标加上当前速度得到下一步的位置坐标</span><br><span class="line">        if (node.fx == null) node.x += node.vx *= velocityDecay;</span><br><span class="line">        else node.x = node.fx, node.vx = 0;</span><br><span class="line">        if (node.fy == null) node.y += node.vy *= velocityDecay;</span><br><span class="line">        else node.y = node.fy, node.vy = 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //对nodes进行处理</span><br><span class="line">    function initializeNodes() &#123;</span><br><span class="line">      for (var i = 0, n = nodes.length, node; i &lt; n; ++i) &#123;</span><br><span class="line">        node = nodes[i], node.index = i;</span><br><span class="line">        //如果node中不含x、 y值，则按默认方法计算。</span><br><span class="line">        if (isNaN(node.x) || isNaN(node.y)) &#123;</span><br><span class="line">          var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;</span><br><span class="line">          node.x = radius * Math.cos(angle);</span><br><span class="line">          node.y = radius * Math.sin(angle);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不含vx、vy值，则默认为0。</span><br><span class="line">        if (isNaN(node.vx) || isNaN(node.vy)) &#123;</span><br><span class="line">          node.vx = node.vy = 0;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initializeForce(force) &#123;</span><br><span class="line">      if (force.initialize) force.initialize(nodes);</span><br><span class="line">      return force;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initializeNodes();</span><br><span class="line"></span><br><span class="line">    return simulation = &#123;</span><br><span class="line">      tick: tick,</span><br><span class="line"></span><br><span class="line">      restart: function() &#123;</span><br><span class="line">        return stepper.restart(step), simulation;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      stop: function() &#123;</span><br><span class="line">        return stepper.stop(), simulation;</span><br><span class="line">      &#125;,</span><br><span class="line">      //设置nodes时会对所有的force进行初始化</span><br><span class="line">      nodes: function(_) &#123;</span><br><span class="line">        return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      alpha: function(_) &#123;</span><br><span class="line">        return arguments.length ? (alpha = +_, simulation) : alpha;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      alphaMin: function(_) &#123;</span><br><span class="line">        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      alphaDecay: function(_) &#123;</span><br><span class="line">        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      alphaTarget: function(_) &#123;</span><br><span class="line">        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      velocityDecay: function(_) &#123;</span><br><span class="line">        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      force: function(name, _) &#123;</span><br><span class="line">        return arguments.length &gt; 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      find: function(x, y, radius) &#123;</span><br><span class="line">        var i = 0,</span><br><span class="line">            n = nodes.length,</span><br><span class="line">            dx,</span><br><span class="line">            dy,</span><br><span class="line">            d2,</span><br><span class="line">            node,</span><br><span class="line">            closest;</span><br><span class="line"></span><br><span class="line">        if (radius == null) radius = Infinity;</span><br><span class="line">        else radius *= radius;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">          node = nodes[i];</span><br><span class="line">          dx = x - node.x;</span><br><span class="line">          dy = y - node.y;</span><br><span class="line">          d2 = dx * dx + dy * dy;</span><br><span class="line">          if (d2 &lt; radius) closest = node, radius = d2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return closest;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      on: function(name, _) &#123;</span><br><span class="line">        return arguments.length &gt; 1 ? (event.on(name, _), simulation) : event.on(name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法对nodes进行处理，计算其x和y值以及初始化vx、vy值，其中很重要的一部分是force函数，该函数用来模拟物理作用力来改变nodes的位置和速度。</p><h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>force函数在定时器执行过程中会重复调用，用于控制nodes的坐标和速度。</p><h3 id="d3-forceLink"><a href="#d3-forceLink" class="headerlink" title="d3.forceLink"></a>d3.forceLink</h3><p>forceLink主要用于nodes之间的联系即links，每个link会将两个不同的node以source和target的方式进行连接，同时内部会对vx、vy进行调整。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">/* d3.forceLink</span><br><span class="line">   * force用于控制节点之间的联系</span><br><span class="line">   * !将于节点相连的link的数量记作该节点的权值</span><br><span class="line">   */</span><br><span class="line">function link(links) &#123;</span><br><span class="line">    var id = index$2,</span><br><span class="line">        strength = defaultStrength,</span><br><span class="line">        strengths,</span><br><span class="line">        //默认link的长度都为30</span><br><span class="line">        distance = constant$6(30),</span><br><span class="line">        distances,</span><br><span class="line">        nodes,</span><br><span class="line">        //count记录跟每个节点有关联的节点数量，即该节点的权值</span><br><span class="line">        count,</span><br><span class="line">        //bias存储每条link对应的source的权值与source和target权值和的比值</span><br><span class="line">        bias,</span><br><span class="line">        iterations = 1;</span><br><span class="line"></span><br><span class="line">    if (links == null) links = [];</span><br><span class="line">    //默认计算link的强度的方法</span><br><span class="line">    function defaultStrength(link) &#123;</span><br><span class="line">      return 1 / Math.min(count[link.source.index], count[link.target.index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function force(alpha) &#123;</span><br><span class="line">      for (var k = 0, n = links.length; k &lt; iterations; ++k) &#123;</span><br><span class="line">        for (var i = 0, link, source, target, x, y, l, b; i &lt; n; ++i) &#123;</span><br><span class="line">          link = links[i], source = link.source, target = link.target;</span><br><span class="line">          x = target.x + target.vx - source.x - source.vx || jiggle();</span><br><span class="line">          y = target.y + target.vy - source.y - source.vy || jiggle();</span><br><span class="line">          //target和source的距离为l</span><br><span class="line">          l = Math.sqrt(x * x + y * y);</span><br><span class="line">          l = (l - distances[i]) / l * alpha * strengths[i];</span><br><span class="line">          x *= l, y *= l;</span><br><span class="line">          //对target和source的速度进行调整</span><br><span class="line">          target.vx -= x * (b = bias[i]);</span><br><span class="line">          target.vy -= y * b;</span><br><span class="line">          source.vx += x * (b = 1 - b);</span><br><span class="line">          source.vy += y * b;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() &#123;</span><br><span class="line">      if (!nodes) return;</span><br><span class="line"></span><br><span class="line">      var i,</span><br><span class="line">          n = nodes.length,</span><br><span class="line">          m = links.length,</span><br><span class="line">          //对nodes中每个值设置id作为键值</span><br><span class="line">          nodeById = map$1(nodes, id),</span><br><span class="line">          link;</span><br><span class="line"></span><br><span class="line">      for (i = 0, count = new Array(n); i &lt; n; ++i) &#123;</span><br><span class="line">        count[i] = 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        link = links[i], link.index = i;</span><br><span class="line">        //将link中的source和target值作为id来查找node</span><br><span class="line">        if (typeof link.source !== &quot;object&quot;) link.source = nodeById.get(link.source);</span><br><span class="line">        if (typeof link.target !== &quot;object&quot;) link.target = nodeById.get(link.target);</span><br><span class="line">        ++count[link.source.index], ++count[link.target.index];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (i = 0, bias = new Array(m); i &lt; m; ++i) &#123;</span><br><span class="line">        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      strengths = new Array(m), initializeStrength();</span><br><span class="line">      distances = new Array(m), initializeDistance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initializeStrength() &#123;</span><br><span class="line">      if (!nodes) return;</span><br><span class="line"></span><br><span class="line">      for (var i = 0, n = links.length; i &lt; n; ++i) &#123;</span><br><span class="line">        strengths[i] = +strength(links[i], i, links);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initializeDistance() &#123;</span><br><span class="line">      if (!nodes) return;</span><br><span class="line"></span><br><span class="line">      for (var i = 0, n = links.length; i &lt; n; ++i) &#123;</span><br><span class="line">        distances[i] = +distance(links[i], i, links);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    force.initialize = function(_) &#123;</span><br><span class="line">      nodes = _;</span><br><span class="line">      initialize();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.links = function(_) &#123;</span><br><span class="line">      return arguments.length ? (links = _, initialize(), force) : links;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.id = function(_) &#123;</span><br><span class="line">      return arguments.length ? (id = _, force) : id;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.iterations = function(_) &#123;</span><br><span class="line">      return arguments.length ? (iterations = +_, force) : iterations;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.strength = function(_) &#123;</span><br><span class="line">      return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initializeStrength(), force) : strength;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.distance = function(_) &#123;</span><br><span class="line">      return arguments.length ? (distance = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initializeDistance(), force) : distance;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return force;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-forceCenter"><a href="#d3-forceCenter" class="headerlink" title="d3.forceCenter"></a>d3.forceCenter</h3><p>forceCenter根据设置的(x, y)坐标而将node的坐标向其移动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//d3.forceCenter</span><br><span class="line">function center$1(x, y) &#123;</span><br><span class="line">    var nodes;</span><br><span class="line"></span><br><span class="line">    if (x == null) x = 0;</span><br><span class="line">    if (y == null) y = 0;</span><br><span class="line"></span><br><span class="line">    function force() &#123;</span><br><span class="line">      var i,</span><br><span class="line">          n = nodes.length,</span><br><span class="line">          node,</span><br><span class="line">          sx = 0,</span><br><span class="line">          sy = 0;</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        node = nodes[i], sx += node.x, sy += node.y;</span><br><span class="line">      &#125;</span><br><span class="line">      //这里简化了粒子的质量，认为都相等，通过sx / n和sy / n得到所有粒子的重心</span><br><span class="line">      for (sx = sx / n - x, sy = sy / n - y, i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        //将所有粒子的坐标向中心点靠近</span><br><span class="line">        node = nodes[i], node.x -= sx, node.y -= sy;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    force.initialize = function(_) &#123;</span><br><span class="line">      nodes = _;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.x = function(_) &#123;</span><br><span class="line">      return arguments.length ? (x = +_, force) : x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.y = function(_) &#123;</span><br><span class="line">      return arguments.length ? (y = +_, force) : y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return force;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-forceCollide"><a href="#d3-forceCollide" class="headerlink" title="d3.forceCollide"></a>d3.forceCollide</h3><p>forceCollide方法将nodes不再看做一个点而是一个指定半径的圆形，防止不同的节点发生碰撞即要满足两个圆心的距离大于两个圆形半径之和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">//d3.forceCollide</span><br><span class="line">function collide(radius) &#123;</span><br><span class="line">    var nodes,</span><br><span class="line">        radii,</span><br><span class="line">        strength = 1,</span><br><span class="line">        iterations = 1;</span><br><span class="line">    //如果没有设置radius，则默认为1</span><br><span class="line">    if (typeof radius !== &quot;function&quot;) radius = constant$6(radius == null ? 1 : +radius);</span><br><span class="line"></span><br><span class="line">    function force() &#123;</span><br><span class="line">      var i, n = nodes.length,</span><br><span class="line">          tree,</span><br><span class="line">          node,</span><br><span class="line">          xi,</span><br><span class="line">          yi,</span><br><span class="line">          ri,</span><br><span class="line">          ri2;</span><br><span class="line"></span><br><span class="line">      for (var k = 0; k &lt; iterations; ++k) &#123;</span><br><span class="line">        //visitAfter函数使得对每个node都执行prepare。这里采用后续遍历的方法，因为只有知道了孩子节点的半径才能确定根节点半径</span><br><span class="line">        tree = quadtree(nodes, x$1, y$1).visitAfter(prepare);</span><br><span class="line">        //依次访问所有的node节点，判断其他节点是否可能与其重叠</span><br><span class="line">        for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">          node = nodes[i];</span><br><span class="line">          ri = radii[i], ri2 = ri * ri;</span><br><span class="line">          xi = node.x + node.vx;</span><br><span class="line">          yi = node.y + node.vy;</span><br><span class="line">          tree.visit(apply);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //这里用于对重叠的节点进行处理，如果当前节点为根节点则判断node是否与该根节点的范围有重叠，如果没有则返回true，不再访问其子节点；否则继续访问其子节点。</span><br><span class="line">      //如果当前节点为叶子节点，</span><br><span class="line">      function apply(quad, x0, y0, x1, y1) &#123;</span><br><span class="line">        var data = quad.data, rj = quad.r, r = ri + rj;</span><br><span class="line">        if (data) &#123;</span><br><span class="line">          // 只比较index大于i的，可防止重复比较</span><br><span class="line">          if (data.index &gt; i) &#123;</span><br><span class="line">            var x = xi - data.x - data.vx,</span><br><span class="line">                y = yi - data.y - data.vy,</span><br><span class="line">                l = x * x + y * y;</span><br><span class="line">            if (l &lt; r * r) &#123;</span><br><span class="line">              if (x === 0) x = jiggle(), l += x * x;</span><br><span class="line">              if (y === 0) y = jiggle(), l += y * y;</span><br><span class="line">              l = (r - (l = Math.sqrt(l))) / l * strength;</span><br><span class="line">              //根据两个节点间的距离和两个节点的半径对node和data的速度进行调整</span><br><span class="line">              //TODO: 为什么这样调整？？？</span><br><span class="line">              node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));</span><br><span class="line">              node.vy += (y *= l) * r;</span><br><span class="line">              data.vx -= x * (r = 1 - r);</span><br><span class="line">              data.vy -= y * r;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        return x0 &gt; xi + r || x1 &lt; xi - r || y0 &gt; yi + r || y1 &lt; yi - r;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //为所有节点设置半径</span><br><span class="line">    function prepare(quad) &#123;</span><br><span class="line">      if (quad.data) return quad.r = radii[quad.data.index];</span><br><span class="line">      //quad是一个数组，即quad不是叶子节点时，将其所有子节点的最大半径复制给quad.r</span><br><span class="line">      for (var i = quad.r = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">        if (quad[i] &amp;&amp; quad[i].r &gt; quad.r) &#123;</span><br><span class="line">          quad.r = quad[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化时通过radius函数处理nodes得到每个node的半径</span><br><span class="line">    force.initialize = function(_) &#123;</span><br><span class="line">      var i, n = (nodes = _).length; radii = new Array(n);</span><br><span class="line">      for (i = 0; i &lt; n; ++i) radii[i] = +radius(nodes[i], i, nodes);</span><br><span class="line">    &#125;;</span><br><span class="line">    //iteration值越大，node节点重叠情况就会越小</span><br><span class="line">    force.iterations = function(_) &#123;</span><br><span class="line">      return arguments.length ? (iterations = +_, force) : iterations;</span><br><span class="line">    &#125;;</span><br><span class="line">    //strength用于在两个节点重叠时调整节点的速度</span><br><span class="line">    force.strength = function(_) &#123;</span><br><span class="line">      return arguments.length ? (strength = +_, force) : strength;</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置节点的获取半径的函数</span><br><span class="line">    force.radius = function(_) &#123;</span><br><span class="line">      return arguments.length ? (radius = typeof _ === &quot;function&quot; ? _ : constant$6(+_), force) : radius;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return force;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-forceManyBody"><a href="#d3-forceManyBody" class="headerlink" title="d3.forceManyBody"></a>d3.forceManyBody</h3><p>用于模拟所有粒子间的作用力，例如模拟重力或者静电力。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">//d3.forceManyBody</span><br><span class="line">function manyBody() &#123;</span><br><span class="line">    var nodes,</span><br><span class="line">        node,</span><br><span class="line">        alpha,</span><br><span class="line">        //当strength为正值时粒子间会互相吸引，当为负值时粒子间会互相排斥</span><br><span class="line">        //在这里表现为当strength为正值时，两个互相作用的粒子速度会增加，互相靠近；为负值时，两个粒子速度减小，互相远离。</span><br><span class="line">        strength = constant$6(-30),</span><br><span class="line">        strengths,</span><br><span class="line">        distanceMin2 = 1,</span><br><span class="line">        distanceMax2 = Infinity,</span><br><span class="line">        //theta用于判断距离远近而采取不同的方法对粒子的速度进行处理</span><br><span class="line">        theta2 = 0.81;</span><br><span class="line"></span><br><span class="line">    function force(_) &#123;</span><br><span class="line">      var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);</span><br><span class="line">      for (alpha = _, i = 0; i &lt; n; ++i) node = nodes[i], tree.visit(apply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() &#123;</span><br><span class="line">      if (!nodes) return;</span><br><span class="line">      var i, n = nodes.length;</span><br><span class="line">      strengths = new Array(n);</span><br><span class="line">      for (i = 0; i &lt; n; ++i) strengths[i] = +strength(nodes[i], i, nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function accumulate(quad) &#123;</span><br><span class="line">      var strength = 0, q, c, x, y, i;</span><br><span class="line"></span><br><span class="line">      // 对于根节点，根据其子节点来计算</span><br><span class="line">      if (quad.length) &#123;</span><br><span class="line">        for (x = y = i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">          if ((q = quad[i]) &amp;&amp; (c = q.value)) &#123;</span><br><span class="line">            strength += c, x += c * q.x, y += c * q.y;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quad.x = x / strength;</span><br><span class="line">        quad.y = y / strength;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 对于叶子节点，根据其是否有相同节点来计算strength值</span><br><span class="line">      else &#123;</span><br><span class="line">        q = quad;</span><br><span class="line">        q.x = q.data.x;</span><br><span class="line">        q.y = q.data.y;</span><br><span class="line">        do strength += strengths[q.data.index];</span><br><span class="line">        while (q = q.next);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      quad.value = strength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function apply(quad, x1, _, x2) &#123;</span><br><span class="line">      if (!quad.value) return true;</span><br><span class="line"></span><br><span class="line">      var x = quad.x - node.x,</span><br><span class="line">          y = quad.y - node.y,</span><br><span class="line">          w = x2 - x1,</span><br><span class="line">          l = x * x + y * y;</span><br><span class="line"></span><br><span class="line">      // 如果quad和node间的距离较远则根据value、alpha和l来调整node的速度</span><br><span class="line">      if (w * w / theta2 &lt; l) &#123;</span><br><span class="line">        if (l &lt; distanceMax2) &#123;</span><br><span class="line">          if (x === 0) x = jiggle(), l += x * x;</span><br><span class="line">          if (y === 0) y = jiggle(), l += y * y;</span><br><span class="line">          if (l &lt; distanceMin2) l = Math.sqrt(distanceMin2 * l);</span><br><span class="line">          node.vx += x * quad.value * alpha / l;</span><br><span class="line">          node.vy += y * quad.value * alpha / l;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如果quad为根节点则返回去访问其子节点</span><br><span class="line">      else if (quad.length || l &gt;= distanceMax2) return;</span><br><span class="line">      //quad和node相同时不会执行以下过程</span><br><span class="line">      //当quad和node间距离较近时，同时要考虑strength来调整node的速度</span><br><span class="line">      </span><br><span class="line">      if (quad.data !== node || quad.next) &#123;</span><br><span class="line">        if (x === 0) x = jiggle(), l += x * x;</span><br><span class="line">        if (y === 0) y = jiggle(), l += y * y;</span><br><span class="line">        if (l &lt; distanceMin2) l = Math.sqrt(distanceMin2 * l);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      do if (quad.data !== node) &#123;</span><br><span class="line">        w = strengths[quad.data.index] * alpha / l;</span><br><span class="line">        node.vx += x * w;</span><br><span class="line">        node.vy += y * w;</span><br><span class="line">      &#125; while (quad = quad.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    force.initialize = function(_) &#123;</span><br><span class="line">      nodes = _;</span><br><span class="line">      initialize();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.strength = function(_) &#123;</span><br><span class="line">      return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initialize(), force) : strength;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.distanceMin = function(_) &#123;</span><br><span class="line">      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.distanceMax = function(_) &#123;</span><br><span class="line">      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.theta = function(_) &#123;</span><br><span class="line">      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return force;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-forceX"><a href="#d3-forceX" class="headerlink" title="d3.forceX"></a>d3.forceX</h3><p>使所有的节点向指定的x坐标处靠近。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//d3.forceX</span><br><span class="line">function x$3(x) &#123;</span><br><span class="line">    var strength = constant$6(0.1),</span><br><span class="line">        nodes,</span><br><span class="line">        strengths,</span><br><span class="line">        xz;</span><br><span class="line"></span><br><span class="line">    if (typeof x !== &quot;function&quot;) x = constant$6(x == null ? 0 : +x);</span><br><span class="line"></span><br><span class="line">    function force(alpha) &#123;</span><br><span class="line">      for (var i = 0, n = nodes.length, node; i &lt; n; ++i) &#123;</span><br><span class="line">        //通过xz和strength来改变node的x轴方向的速度，使得节点像xz处靠近。strength的值越大，node的速度改变的越快，即会更快的到达指定坐标位置而趋于稳定</span><br><span class="line">        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() &#123;</span><br><span class="line">      if (!nodes) return;</span><br><span class="line">      var i, n = nodes.length;</span><br><span class="line">      strengths = new Array(n);</span><br><span class="line">      xz = new Array(n);</span><br><span class="line">      for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        //对每个node分别计算x坐标存入xz数组中，同时计算strength值</span><br><span class="line">        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    force.initialize = function(_) &#123;</span><br><span class="line">      nodes = _;</span><br><span class="line">      initialize();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.strength = function(_) &#123;</span><br><span class="line">      return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initialize(), force) : strength;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    force.x = function(_) &#123;</span><br><span class="line">      return arguments.length ? (x = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initialize(), force) : x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return force;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该模块用于模拟在粒子上的物理作用力，常用于网络图和层级图。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Path</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-path/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-path/</id>
    <published>2016-09-21T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.461Z</updated>
    
    <content type="html"><![CDATA[<p>d3的path部分是对原生绘制方法的一种封装形式。由于d3.js内部是以svg作为默认的绘图方式，因此内部的计算方式都是将数据转换成svg中<code>path</code>元素的<code>d</code>属性值。通过统一的接口让其和canvas绘图的api保持一致。<br><a id="more"></a></p><h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>d3的path部分是为了模拟<code>canvas</code>的绘图方式，但是采用的是svg来作图。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">//path构造函数</span><br><span class="line">function Path() &#123;</span><br><span class="line">    this._x0 = this._y0 = // 当前路径的起点</span><br><span class="line">    this._x1 = this._y1 = null; // 当前路径的终点</span><br><span class="line">    this._ = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function path() &#123;</span><br><span class="line">    return new Path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Path.prototype = path.prototype = &#123;</span><br><span class="line">    constructor: Path,</span><br><span class="line">    //移动至指定位置</span><br><span class="line">    moveTo: function(x, y) &#123;</span><br><span class="line">      this._.push(&quot;M&quot;, this._x0 = this._x1 = +x, &quot;,&quot;, this._y0 = this._y1 = +y);</span><br><span class="line">    &#125;,</span><br><span class="line">    //关闭路径</span><br><span class="line">    closePath: function() &#123;</span><br><span class="line">      if (this._x1 !== null) &#123;</span><br><span class="line">        this._x1 = this._x0, this._y1 = this._y0;</span><br><span class="line">        this._.push(&quot;Z&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //绘制直线</span><br><span class="line">    lineTo: function(x, y) &#123;</span><br><span class="line">      this._.push(&quot;L&quot;, this._x1 = +x, &quot;,&quot;, this._y1 = +y);</span><br><span class="line">    &#125;,</span><br><span class="line">    //绘制二次贝塞尔曲线</span><br><span class="line">    quadraticCurveTo: function(x1, y1, x, y) &#123;</span><br><span class="line">      // Q x1 x2（控制点）, x y（终点）</span><br><span class="line">      this._.push(&quot;Q&quot;, +x1, &quot;,&quot;, +y1, &quot;,&quot;, this._x1 = +x, &quot;,&quot;, this._y1 = +y);</span><br><span class="line">    &#125;,</span><br><span class="line">    //绘制三次贝塞尔曲线</span><br><span class="line">    bezierCurveTo: function(x1, y1, x2, y2, x, y) &#123;</span><br><span class="line">      this._.push(&quot;C&quot;, +x1, &quot;,&quot;, +y1, &quot;,&quot;, +x2, &quot;,&quot;, +y2, &quot;,&quot;, this._x1 = +x, &quot;,&quot;, this._y1 = +y);</span><br><span class="line">    &#125;,</span><br><span class="line">    arcTo: function(x1, y1, x2, y2, r) &#123;</span><br><span class="line">      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;</span><br><span class="line">      var x0 = this._x1,</span><br><span class="line">          y0 = this._y1,</span><br><span class="line">          x21 = x2 - x1,</span><br><span class="line">          y21 = y2 - y1,</span><br><span class="line">          x01 = x0 - x1,</span><br><span class="line">          y01 = y0 - y1,</span><br><span class="line">          l01_2 = x01 * x01 + y01 * y01;</span><br><span class="line"></span><br><span class="line">      // Is the radius negative? Error.</span><br><span class="line">      if (r &lt; 0) throw new Error(&quot;negative radius: &quot; + r);</span><br><span class="line"></span><br><span class="line">      // Is this path empty? Move to (x1,y1).</span><br><span class="line">      if (this._x1 === null) &#123;</span><br><span class="line">        this._.push(</span><br><span class="line">          &quot;M&quot;, this._x1 = x1, &quot;,&quot;, this._y1 = y1</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.</span><br><span class="line">      else if (!(l01_2 &gt; epsilon));</span><br><span class="line"></span><br><span class="line">      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?</span><br><span class="line">      // Equivalently, is (x1,y1) coincident with (x2,y2)?</span><br><span class="line">      // Or, is the radius zero? Line to (x1,y1).</span><br><span class="line">      else if (!(Math.abs(y01 * x21 - y21 * x01) &gt; epsilon) || !r) &#123;</span><br><span class="line">        this._.push(</span><br><span class="line">          &quot;L&quot;, this._x1 = x1, &quot;,&quot;, this._y1 = y1</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Otherwise, draw an arc!</span><br><span class="line">      else &#123;</span><br><span class="line">        var x20 = x2 - x0,</span><br><span class="line">            y20 = y2 - y0,</span><br><span class="line">            l21_2 = x21 * x21 + y21 * y21,</span><br><span class="line">            l20_2 = x20 * x20 + y20 * y20,</span><br><span class="line">            l21 = Math.sqrt(l21_2),</span><br><span class="line">            l01 = Math.sqrt(l01_2),</span><br><span class="line">            l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),</span><br><span class="line">            t01 = l / l01,</span><br><span class="line">            t21 = l / l21;</span><br><span class="line"></span><br><span class="line">        // If the start tangent is not coincident with (x0,y0), line to.</span><br><span class="line">        if (Math.abs(t01 - 1) &gt; epsilon) &#123;</span><br><span class="line">          this._.push(</span><br><span class="line">            &quot;L&quot;, x1 + t01 * x01, &quot;,&quot;, y1 + t01 * y01</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this._.push(</span><br><span class="line">          &quot;A&quot;, r, &quot;,&quot;, r, &quot;,0,0,&quot;, +(y01 * x20 &gt; x01 * y20), &quot;,&quot;, this._x1 = x1 + t21 * x21, &quot;,&quot;, this._y1 = y1 + t21 * y21</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //(x, y)为参照点坐标，a0和a1分别为起点弧度和终点弧度</span><br><span class="line">    arc: function(x, y, r, a0, a1, ccw) &#123;</span><br><span class="line">      x = +x, y = +y, r = +r;</span><br><span class="line">      var dx = r * Math.cos(a0),</span><br><span class="line">          dy = r * Math.sin(a0),</span><br><span class="line">          //起点(x0, y0)坐标</span><br><span class="line">          x0 = x + dx,</span><br><span class="line">          y0 = y + dy,</span><br><span class="line">          //clockwise，顺时针</span><br><span class="line">          cw = 1 ^ ccw,</span><br><span class="line">          da = ccw ? a0 - a1 : a1 - a0;</span><br><span class="line"></span><br><span class="line">      if (r &lt; 0) throw new Error(&quot;negative radius: &quot; + r);</span><br><span class="line"></span><br><span class="line">      // 如果path为空，则move到(x0, y0)</span><br><span class="line">      if (this._x1 === null) &#123;</span><br><span class="line">        this._.push(</span><br><span class="line">          &quot;M&quot;, x0, &quot;,&quot;, y0</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // (x0, y0)与之前位置不一致，用直线连接到(x0, y0)</span><br><span class="line">      else if (Math.abs(this._x1 - x0) &gt; epsilon || Math.abs(this._y1 - y0) &gt; epsilon) &#123;</span><br><span class="line">        this._.push(</span><br><span class="line">          &quot;L&quot;, x0, &quot;,&quot;, y0</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!r) return;</span><br><span class="line"></span><br><span class="line">      // 如果是一个圆，直接画两个圆弧实现这个圆形</span><br><span class="line">      // A rx（x轴半径） ry（y轴半径） x-axis-rotation（x轴逆时针旋转角度） large-arc-flag（0表示小角度弧即小于180°，1表示大角度弧） sweep-flag（0表示从起点到终点逆时针画弧，1表示顺时针） x（弧线终点x轴） y（弧线终点y轴）</span><br><span class="line">      if (da &gt; tauEpsilon) &#123;</span><br><span class="line">        this._.push(</span><br><span class="line">          &quot;A&quot;, r, &quot;,&quot;, r, &quot;,0,1,&quot;, cw, &quot;,&quot;, x - dx, &quot;,&quot;, y - dy,</span><br><span class="line">          &quot;A&quot;, r, &quot;,&quot;, r, &quot;,0,1,&quot;, cw, &quot;,&quot;, this._x1 = x0, &quot;,&quot;, this._y1 = y0</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 以r为半径，从当前点向endAngle位置画弧线</span><br><span class="line">      else &#123;</span><br><span class="line">        if (da &lt; 0) da = da % tau$1 + tau$1;</span><br><span class="line">        this._.push(</span><br><span class="line">          &quot;A&quot;, r, &quot;,&quot;, r, &quot;,0,&quot;, +(da &gt;= pi$1), &quot;,&quot;, cw, &quot;,&quot;, this._x1 = x + r * Math.cos(a1), &quot;,&quot;, this._y1 = y + r * Math.sin(a1)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    rect: function(x, y, w, h) &#123;</span><br><span class="line">      this._.push(&quot;M&quot;, this._x0 = this._x1 = +x, &quot;,&quot;, this._y0 = this._y1 = +y, &quot;h&quot;, +w, &quot;v&quot;, +h, &quot;h&quot;, -w, &quot;Z&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 将整个数组转化成一个字符串</span><br><span class="line">    toString: function() &#123;</span><br><span class="line">      return this._.join(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;d3的path部分是对原生绘制方法的一种封装形式。由于d3.js内部是以svg作为默认的绘图方式，因此内部的计算方式都是将数据转换成svg中&lt;code&gt;path&lt;/code&gt;元素的&lt;code&gt;d&lt;/code&gt;属性值。通过统一的接口让其和canvas绘图的api保持一致。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Shape</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-shape/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-shape/</id>
    <published>2016-09-14T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.463Z</updated>
    
    <content type="html"><![CDATA[<p>shape模块提供各种形状的生成器，这些形状的产生是数据驱动的，通过控制输入数据来形成一种视觉的表现。<br><a id="more"></a></p><h2 id="Pies"><a href="#Pies" class="headerlink" title="Pies"></a>Pies</h2><p>饼图生成器不直接产生图形，而是计算出需要的角度信息，然后传入<code>d3.arc</code>中进行绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">  // 绘制饼图</span><br><span class="line">function pie() &#123;</span><br><span class="line">    var value = identity$1,</span><br><span class="line">        sortValues = descending$1,</span><br><span class="line">        sort = null,</span><br><span class="line">        startAngle = constant$1(0),</span><br><span class="line">        endAngle = constant$1(tau$2),</span><br><span class="line">        padAngle = constant$1(0);</span><br><span class="line"></span><br><span class="line">    function pie(data) &#123;</span><br><span class="line">      var i,</span><br><span class="line">          n = data.length,</span><br><span class="line">          j,</span><br><span class="line">          k,</span><br><span class="line">          //统计data数组中的数据和</span><br><span class="line">          sum = 0,</span><br><span class="line">          index = new Array(n),</span><br><span class="line">          arcs = new Array(n),</span><br><span class="line">          a0 = +startAngle.apply(this, arguments),</span><br><span class="line">          //将|endAngle - startAngle|限定在 2 * PI之间</span><br><span class="line">          da = Math.min(tau$2, Math.max(-tau$2, endAngle.apply(this, arguments) - a0)),</span><br><span class="line">          a1,</span><br><span class="line">          //限定padAngle的范围</span><br><span class="line">          p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),</span><br><span class="line">          // da&lt;0表示弧线为逆时针方向，pa的值也应进行相应处理</span><br><span class="line">          pa = p * (da &lt; 0 ? -1 : 1),</span><br><span class="line">          v;</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if ((v = arcs[index[i] = i] = +value(data[i], i, data)) &gt; 0) &#123;</span><br><span class="line">          sum += v;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 按照处理后的arcs数据大小对index进行排序，或者直接对data进行排序</span><br><span class="line">      if (sortValues != null) index.sort(function(i, j) &#123; return sortValues(arcs[i], arcs[j]); &#125;);</span><br><span class="line">      else if (sort != null) index.sort(function(i, j) &#123; return sort(data[i], data[j]); &#125;);</span><br><span class="line"></span><br><span class="line">      // 计算arcs，按照排序后的index来逐个计算</span><br><span class="line">      for (i = 0, k = sum ? (da - n * pa) / sum : 0; i &lt; n; ++i, a0 = a1) &#123;</span><br><span class="line">        j = index[i], v = arcs[j], a1 = a0 + (v &gt; 0 ? v * k : 0) + pa, arcs[j] = &#123;</span><br><span class="line">          data: data[j],</span><br><span class="line">          index: i,</span><br><span class="line">          value: v,</span><br><span class="line">          startAngle: a0,</span><br><span class="line">          endAngle: a1,</span><br><span class="line">          padAngle: p</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return arcs;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置value函数或数值，value函数会被依次传入data[i]、i和data。</span><br><span class="line">    pie.value = function(_) &#123;</span><br><span class="line">      return arguments.length ? (value = typeof _ === &quot;function&quot; ? _ : constant$1(+_), pie) : value;</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置数值的排序方式</span><br><span class="line">    pie.sortValues = function(_) &#123;</span><br><span class="line">      return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    pie.sort = function(_) &#123;</span><br><span class="line">      return arguments.length ? (sort = _, sortValues = null, pie) : sort;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    pie.startAngle = function(_) &#123;</span><br><span class="line">      return arguments.length ? (startAngle = typeof _ === &quot;function&quot; ? _ : constant$1(+_), pie) : startAngle;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    pie.endAngle = function(_) &#123;</span><br><span class="line">      return arguments.length ? (endAngle = typeof _ === &quot;function&quot; ? _ : constant$1(+_), pie) : endAngle;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    pie.padAngle = function(_) &#123;</span><br><span class="line">      return arguments.length ? (padAngle = typeof _ === &quot;function&quot; ? _ : constant$1(+_), pie) : padAngle;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return pie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Lines"><a href="#Lines" class="headerlink" title="Lines"></a>Lines</h2><p>可以产生样条曲线或者多段线。</p><h3 id="d3-line"><a href="#d3-line" class="headerlink" title="d3.line"></a>d3.line</h3><p>默认的设置是构造多条直线段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//d3.line()，绘制多条直线段，中间可能断开</span><br><span class="line">  function line() &#123;</span><br><span class="line">    var x$$ = x,</span><br><span class="line">        y$$ = y,</span><br><span class="line">        defined = constant$1(true),</span><br><span class="line">        context = null,</span><br><span class="line">        curve = curveLinear,</span><br><span class="line">        output = null;</span><br><span class="line"></span><br><span class="line">    function line(data) &#123;</span><br><span class="line">      var i,</span><br><span class="line">          n = data.length,</span><br><span class="line">          d,</span><br><span class="line">          defined0 = false,</span><br><span class="line">          buffer;</span><br><span class="line"></span><br><span class="line">      if (context == null) output = curve(buffer = path());</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt;= n; ++i) &#123;</span><br><span class="line">        if (!(i &lt; n &amp;&amp; defined(d = data[i], i, data)) === defined0) &#123;</span><br><span class="line">          if (defined0 = !defined0) output.lineStart();</span><br><span class="line">          else output.lineEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        if (defined0) output.point(+x$$(d, i, data), +y$$(d, i, data));</span><br><span class="line">      &#125;</span><br><span class="line">    // 返回path的计算结果</span><br><span class="line">      if (buffer) return output = null, buffer + &quot;&quot; || null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置获取x的函数</span><br><span class="line">    line.x = function(_) &#123;</span><br><span class="line">      return arguments.length ? (x$$ = typeof _ === &quot;function&quot; ? _ : constant$1(+_), line) : x$$;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置获取y的函数</span><br><span class="line">    line.y = function(_) &#123;</span><br><span class="line">      return arguments.length ? (y$$ = typeof _ === &quot;function&quot; ? _ : constant$1(+_), line) : y$$;</span><br><span class="line">    &#125;;</span><br><span class="line">    // defined函数用于判断当前点是否已被定义，若为true，则会计算x、y坐标和绘制直线；否则会跳过当前点，结束当前直线的绘制。</span><br><span class="line">    line.defined = function(_) &#123;</span><br><span class="line">      return arguments.length ? (defined = typeof _ === &quot;function&quot; ? _ : constant$1(!!_), line) : defined;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置curve函数</span><br><span class="line">    line.curve = function(_) &#123;</span><br><span class="line">      return arguments.length ? (curve = _, context != null &amp;&amp; (output = curve(context)), line) : curve;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置context</span><br><span class="line">    line.context = function(_) &#123;</span><br><span class="line">      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-radialLine"><a href="#d3-radialLine" class="headerlink" title="d3.radialLine"></a>d3.radialLine</h3><p>构造放射线，与上述<code>d3.line</code>类似，只是将x、y函数替换成角度和半径函数，并且改放射线总是相对于(0, 0)进行绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// d3.radialLine，在d3.line的基础上进行修改，主要的差别是curve函数和坐标系。</span><br><span class="line">function radialLine$1() &#123;</span><br><span class="line">    return radialLine(line().curve(curveRadialLinear));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造放射线，分别构造线性和放射状曲线</span><br><span class="line">var curveRadialLinear = curveRadial(curveLinear);</span><br><span class="line"></span><br><span class="line">//线性的curve函数</span><br><span class="line">function curveLinear(context) &#123;</span><br><span class="line">    return new Linear(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将当前curve函数包装成放射状curve</span><br><span class="line">function curveRadial(curve) &#123;</span><br><span class="line">    function radial(context) &#123;</span><br><span class="line">      return new Radial(curve(context));</span><br><span class="line">    &#125;</span><br><span class="line">    radial._curve = curve;</span><br><span class="line">    return radial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将line中的(x, y)坐标替换成(angle, radius)</span><br><span class="line">function radialLine(l) &#123;</span><br><span class="line">    var c = l.curve;</span><br><span class="line"></span><br><span class="line">    l.angle = l.x, delete l.x;</span><br><span class="line">    l.radius = l.y, delete l.y;</span><br><span class="line"></span><br><span class="line">    l.curve = function(_) &#123;</span><br><span class="line">      return arguments.length ? c(curveRadial(_)) : c()._curve;</span><br><span class="line">    &#125;;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Areas"><a href="#Areas" class="headerlink" title="Areas"></a>Areas</h2><p>用于产生一块区域。</p><h3 id="d3-area"><a href="#d3-area" class="headerlink" title="d3.area"></a>d3.area</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">/* d3.area</span><br><span class="line"> * 首先根据x1, y1函数进行绘制，完成后根据x0, y0函数来反方向绘制，整个图形的绘制过程是顺时针方向。</span><br><span class="line"> * 默认绘制的是x0 = x1，y0 = 0的一块区域。</span><br><span class="line"> */</span><br><span class="line"> function area$1() &#123;</span><br><span class="line">    var x0 = x,</span><br><span class="line">        x1 = null,</span><br><span class="line">        y0 = constant$1(0),</span><br><span class="line">        y1 = y,</span><br><span class="line">        defined = constant$1(true),</span><br><span class="line">        context = null,</span><br><span class="line">        curve = curveLinear,</span><br><span class="line">        output = null;</span><br><span class="line"></span><br><span class="line">    function area(data) &#123;</span><br><span class="line">      var i,</span><br><span class="line">          j,</span><br><span class="line">          k,</span><br><span class="line">          n = data.length,</span><br><span class="line">          d,</span><br><span class="line">          defined0 = false,</span><br><span class="line">          buffer,</span><br><span class="line">          x0z = new Array(n),</span><br><span class="line">          y0z = new Array(n);</span><br><span class="line"></span><br><span class="line">      if (context == null) output = curve(buffer = path());</span><br><span class="line"></span><br><span class="line">      for (i = 0; i &lt;= n; ++i) &#123;</span><br><span class="line">        if (!(i &lt; n &amp;&amp; defined(d = data[i], i, data)) === defined0) &#123;</span><br><span class="line">          //defined0由false变为true时，表示绘制开始，相反表示绘制结束</span><br><span class="line">          if (defined0 = !defined0) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            output.areaStart();</span><br><span class="line">            output.lineStart();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            output.lineEnd();</span><br><span class="line">            output.lineStart();</span><br><span class="line">            //反向绘制x0z, y0z，绘制方向为顺时针方向</span><br><span class="line">            for (k = i - 1; k &gt;= j; --k) &#123;</span><br><span class="line">              output.point(x0z[k], y0z[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            output.lineEnd();</span><br><span class="line">            // 关闭绘制区域</span><br><span class="line">            output.areaEnd();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //defined0为true时可以绘制</span><br><span class="line">        if (defined0) &#123;</span><br><span class="line">          x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);</span><br><span class="line">          //优先使用x1和y1函数进行计算</span><br><span class="line">          output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (buffer) return output = null, buffer + &quot;&quot; || null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回与当前area有相同defined、curve和context的line构造器</span><br><span class="line">    function arealine() &#123;</span><br><span class="line">      return line().defined(defined).curve(curve).context(context);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置x函数，将该函数赋值给x0，null赋值给x1</span><br><span class="line">    area.x = function(_) &#123;</span><br><span class="line">      return arguments.length ? (x0 = typeof _ === &quot;function&quot; ? _ : constant$1(+_), x1 = null, area) : x0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    area.x0 = function(_) &#123;</span><br><span class="line">      return arguments.length ? (x0 = typeof _ === &quot;function&quot; ? _ : constant$1(+_), area) : x0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    area.x1 = function(_) &#123;</span><br><span class="line">      return arguments.length ? (x1 = _ == null ? null : typeof _ === &quot;function&quot; ? _ : constant$1(+_), area) : x1;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置y函数，将该函数赋值给y0，null赋值给y1</span><br><span class="line">    area.y = function(_) &#123;</span><br><span class="line">      return arguments.length ? (y0 = typeof _ === &quot;function&quot; ? _ : constant$1(+_), y1 = null, area) : y0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    area.y0 = function(_) &#123;</span><br><span class="line">      return arguments.length ? (y0 = typeof _ === &quot;function&quot; ? _ : constant$1(+_), area) : y0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    area.y1 = function(_) &#123;</span><br><span class="line">      return arguments.length ? (y1 = _ == null ? null : typeof _ === &quot;function&quot; ? _ : constant$1(+_), area) : y1;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 分别对line构造器设置x和y函数</span><br><span class="line">    area.lineX0 =</span><br><span class="line">    area.lineY0 = function() &#123;</span><br><span class="line">      return arealine().x(x0).y(y0);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    area.lineY1 = function() &#123;</span><br><span class="line">      return arealine().x(x0).y(y1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    area.lineX1 = function() &#123;</span><br><span class="line">      return arealine().x(x1).y(y0);</span><br><span class="line">    &#125;;</span><br><span class="line">    // defined函数用来判断是否绘制当前点。这样可以生成离散的图形。</span><br><span class="line">    area.defined = function(_) &#123;</span><br><span class="line">      return arguments.length ? (defined = typeof _ === &quot;function&quot; ? _ : constant$1(!!_), area) : defined;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    area.curve = function(_) &#123;</span><br><span class="line">      return arguments.length ? (curve = _, context != null &amp;&amp; (output = curve(context)), area) : curve;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    area.context = function(_) &#123;</span><br><span class="line">      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return area;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="d3-radialArea"><a href="#d3-radialArea" class="headerlink" title="d3.radialArea"></a>d3.radialArea</h3><p>绘制放射状区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * d3.radialArea</span><br><span class="line"> * 在area的基础上修改curve函数，将x,y坐标转换为angle,radius坐标，其余绘制方式不变</span><br><span class="line"> */</span><br><span class="line">function radialArea() &#123;</span><br><span class="line">    var a = area$1().curve(curveRadialLinear),</span><br><span class="line">        c = a.curve,</span><br><span class="line">        x0 = a.lineX0,</span><br><span class="line">        x1 = a.lineX1,</span><br><span class="line">        y0 = a.lineY0,</span><br><span class="line">        y1 = a.lineY1;</span><br><span class="line">    // 将d3.area中的(x0, y0)和(x1, y1)转化成(startAngle, innerRadius)和(endAngle, outerRadius)</span><br><span class="line">    a.angle = a.x, delete a.x;</span><br><span class="line">    a.startAngle = a.x0, delete a.x0;</span><br><span class="line">    a.endAngle = a.x1, delete a.x1;</span><br><span class="line">    a.radius = a.y, delete a.y;</span><br><span class="line">    a.innerRadius = a.y0, delete a.y0;</span><br><span class="line">    a.outerRadius = a.y1, delete a.y1;</span><br><span class="line">    a.lineStartAngle = function() &#123; return radialLine(x0()); &#125;, delete a.lineX0;</span><br><span class="line">    a.lineEndAngle = function() &#123; return radialLine(x1()); &#125;, delete a.lineX1;</span><br><span class="line">    a.lineInnerRadius = function() &#123; return radialLine(y0()); &#125;, delete a.lineY0;</span><br><span class="line">    a.lineOuterRadius = function() &#123; return radialLine(y1()); &#125;, delete a.lineY1;</span><br><span class="line">    // 对自定义的curve函数进行包装，防止计算时方法不能使用</span><br><span class="line">    a.curve = function(_) &#123;</span><br><span class="line">      return arguments.length ? c(curveRadial(_)) : c()._curve;</span><br><span class="line">    &#125;;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h2><p>curve的功能就是将离散的点进行连接，形成一个连续的图形，它并不是直接使用，而是传入上述如<code>d3.line</code>、<code>d3.area</code>等函数的<code>curve</code>函数中来控制这些离散的点的连接方式。</p><h3 id="d3-curveBasis"><a href="#d3-curveBasis" class="headerlink" title="d3.curveBasis"></a>d3.curveBasis</h3><p>通过特定控制点的贝塞尔曲线将离散的点进行连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function point(that, x, y) &#123;</span><br><span class="line">    that._context.bezierCurveTo(</span><br><span class="line">      (2 * that._x0 + that._x1) / 3,</span><br><span class="line">      (2 * that._y0 + that._y1) / 3,</span><br><span class="line">      (that._x0 + 2 * that._x1) / 3,</span><br><span class="line">      (that._y0 + 2 * that._y1) / 3,</span><br><span class="line">      (that._x0 + 4 * that._x1 + x) / 6,</span><br><span class="line">      (that._y0 + 4 * that._y1 + y) / 6</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">function Basis(context) &#123;</span><br><span class="line">    this._context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Basis.prototype = &#123;</span><br><span class="line">    areaStart: function() &#123;</span><br><span class="line">      this._line = 0;</span><br><span class="line">    &#125;,</span><br><span class="line">    areaEnd: function() &#123;</span><br><span class="line">      this._line = NaN;</span><br><span class="line">    &#125;,</span><br><span class="line">    lineStart: function() &#123;</span><br><span class="line">      this._x0 = this._x1 =</span><br><span class="line">      this._y0 = this._y1 = NaN;</span><br><span class="line">      this._point = 0;</span><br><span class="line">    &#125;,</span><br><span class="line">    lineEnd: function() &#123;</span><br><span class="line">      switch (this._point) &#123;</span><br><span class="line">        case 3: point(this, this._x1, this._y1); // proceed</span><br><span class="line">        case 2: this._context.lineTo(this._x1, this._y1); break;</span><br><span class="line">      &#125;</span><br><span class="line">      if (this._line || (this._line !== 0 &amp;&amp; this._point === 1)) this._context.closePath();</span><br><span class="line">      this._line = 1 - this._line;</span><br><span class="line">    &#125;,</span><br><span class="line">    //首先移动至起点即第一个点，记录下第一个点和第二个点坐标，连接当前点(第一个点)和((5 * x0 + x1) / 6, (5 * y0 + y1) / 6)，并绘制改点到((x0 + 4 * x1 + x) / 6, (y0 + 4 * y1 + y) / 6)点的三次贝塞尔曲线</span><br><span class="line">    point: function(x, y) &#123;</span><br><span class="line">      x = +x, y = +y;</span><br><span class="line">      switch (this._point) &#123;</span><br><span class="line">        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;</span><br><span class="line">        case 1: this._point = 2; break;</span><br><span class="line">        case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed</span><br><span class="line">        default: point(this, x, y); break;</span><br><span class="line">      &#125;</span><br><span class="line">      this._x0 = this._x1, this._x1 = x;</span><br><span class="line">      this._y0 = this._y1, this._y1 = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// d3.curveBasis</span><br><span class="line">function basis(context) &#123;</span><br><span class="line">    return new Basis(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-curveBasisClosed"><a href="#d3-curveBasisClosed" class="headerlink" title="d3.curveBasisClosed"></a>d3.curveBasisClosed</h3><p>通过特定控制点的贝塞尔曲线连接离散的点，并形成一个闭合图形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function BasisClosed(context) &#123;</span><br><span class="line">    this._context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BasisClosed.prototype = &#123;</span><br><span class="line">    areaStart: noop,</span><br><span class="line">    areaEnd: noop,</span><br><span class="line">    //(x1, y1)和(x2, y2)用于记录第一个和第二个点的坐标</span><br><span class="line">    lineStart: function() &#123;</span><br><span class="line">      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =</span><br><span class="line">      this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;</span><br><span class="line">      this._point = 0;</span><br><span class="line">    &#125;,</span><br><span class="line">    lineEnd: function() &#123;</span><br><span class="line">      switch (this._point) &#123;</span><br><span class="line">        //如果只有一个点，则移动到第一个点即该点处并关闭图形</span><br><span class="line">        case 1: &#123;</span><br><span class="line">          this._context.moveTo(this._x2, this._y2);</span><br><span class="line">          this._context.closePath();</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果有两个点，则按如下方式处理</span><br><span class="line">        case 2: &#123;</span><br><span class="line">          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);</span><br><span class="line">          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);</span><br><span class="line">          this._context.closePath();</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        //从最后一个点向前绘制，x2,x3,x4分别记录的是前三个点坐标</span><br><span class="line">        case 3: &#123;</span><br><span class="line">          this.point(this._x2, this._y2);</span><br><span class="line">          this.point(this._x3, this._y3);</span><br><span class="line">          this.point(this._x4, this._y4);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    point: function(x, y) &#123;</span><br><span class="line">      x = +x, y = +y;</span><br><span class="line">      switch (this._point) &#123;</span><br><span class="line">        //记录最初的三个点的坐标</span><br><span class="line">        case 0: this._point = 1; this._x2 = x, this._y2 = y; break;</span><br><span class="line">        case 1: this._point = 2; this._x3 = x, this._y3 = y; break;</span><br><span class="line">        //到最后会绘制一个闭合图形，与初始点连接</span><br><span class="line">        case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;</span><br><span class="line">        default: point(this, x, y); break;</span><br><span class="line">      &#125;</span><br><span class="line">      this._x0 = this._x1, this._x1 = x;</span><br><span class="line">      this._y0 = this._y1, this._y1 = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">//d3.curveBasisClosed</span><br><span class="line">function basisClosed(context) &#123;</span><br><span class="line">    return new BasisClosed(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-curveBasisOpen"><a href="#d3-curveBasisOpen" class="headerlink" title="d3.curveBasisOpen"></a>d3.curveBasisOpen</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function BasisOpen(context) &#123;</span><br><span class="line">    this._context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BasisOpen.prototype = &#123;</span><br><span class="line">    areaStart: function() &#123;</span><br><span class="line">      this._line = 0;</span><br><span class="line">    &#125;,</span><br><span class="line">    areaEnd: function() &#123;</span><br><span class="line">      this._line = NaN;</span><br><span class="line">    &#125;,</span><br><span class="line">    lineStart: function() &#123;</span><br><span class="line">      this._x0 = this._x1 =</span><br><span class="line">      this._y0 = this._y1 = NaN;</span><br><span class="line">      this._point = 0;</span><br><span class="line">    &#125;,</span><br><span class="line">    lineEnd: function() &#123;</span><br><span class="line">      if (this._line || (this._line !== 0 &amp;&amp; this._point === 3)) this._context.closePath();</span><br><span class="line">      this._line = 1 - this._line;</span><br><span class="line">    &#125;,</span><br><span class="line">    //记录第一个和第二个点的坐标，从第三个点处开始操作，移动至((x0 + 4 * x1 + x) / 6, (y0 + y1 * 4 + y) / 6) 点处</span><br><span class="line">    point: function(x, y) &#123;</span><br><span class="line">      x = +x, y = +y;</span><br><span class="line">      switch (this._point) &#123;</span><br><span class="line">        case 0: this._point = 1; break;</span><br><span class="line">        case 1: this._point = 2; break;</span><br><span class="line">        case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;</span><br><span class="line">        case 3: this._point = 4; // proceed</span><br><span class="line">        default: point(this, x, y); break;</span><br><span class="line">      &#125;</span><br><span class="line">      this._x0 = this._x1, this._x1 = x;</span><br><span class="line">      this._y0 = this._y1, this._y1 = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//d3.curveBasisOpen</span><br><span class="line">function basisOpen(context) &#123;</span><br><span class="line">    return new BasisOpen(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="d3-curveBundle"><a href="#d3-curveBundle" class="headerlink" title="d3.curveBundle"></a>d3.curveBundle</h3><p>根据制定的控制点连接离散的点，用于分层级的关系图中，与<code>d3.line</code>一起使用，而不能与<code>d3.area</code>使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Bundle.prototype = &#123;</span><br><span class="line">    lineStart: function() &#123;</span><br><span class="line">      this._x = [];</span><br><span class="line">      this._y = [];</span><br><span class="line">      this._basis.lineStart();</span><br><span class="line">    &#125;,</span><br><span class="line">    //结束时开始处理数据并绘制图形</span><br><span class="line">    lineEnd: function() &#123;</span><br><span class="line">      var x = this._x,</span><br><span class="line">          y = this._y,</span><br><span class="line">          j = x.length - 1;</span><br><span class="line"></span><br><span class="line">      if (j &gt; 0) &#123;</span><br><span class="line">        var x0 = x[0],</span><br><span class="line">            y0 = y[0],</span><br><span class="line">            //计算起始点到结束点之间x和y的差值</span><br><span class="line">            dx = x[j] - x0,</span><br><span class="line">            dy = y[j] - y0,</span><br><span class="line">            i = -1,</span><br><span class="line">            t;</span><br><span class="line"></span><br><span class="line">        while (++i &lt;= j) &#123;</span><br><span class="line">          t = i / j;</span><br><span class="line">          //根据比例确定绘制点的位置，绘制范围在(x0, y0)和(x[j], y[j])之间</span><br><span class="line">          //当x接近0时，结果近似为一条从起始点到结束点的直线；当x接近1时，结果接近d3.curveBasis</span><br><span class="line">          this._basis.point(</span><br><span class="line">            this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),</span><br><span class="line">            this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this._x = this._y = null;</span><br><span class="line">      this._basis.lineEnd();</span><br><span class="line">    &#125;,</span><br><span class="line">    //该方法不会绘制图形，只是将数据存入数组在结束绘制时开始处理数据</span><br><span class="line">    point: function(x, y) &#123;</span><br><span class="line">      this._x.push(+x);</span><br><span class="line">      this._y.push(+y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  //d3.curveBundle</span><br><span class="line">  var bundle = (function custom(beta) &#123;</span><br><span class="line"></span><br><span class="line">    function bundle(context) &#123;</span><br><span class="line">      return beta === 1 ? new Basis(context) : new Bundle(context, beta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bundle.beta = function(beta) &#123;</span><br><span class="line">      return custom(+beta);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return bundle;</span><br><span class="line">&#125;)(0.85);</span><br></pre></td></tr></table></figure></p><h2 id="Custom-Curves"><a href="#Custom-Curves" class="headerlink" title="Custom Curves"></a>Custom Curves</h2><p>自定义curve函数，需要自定义几个指定的方法。</p><ul><li>curve.areaStart()<br>  表示一个新的区域的开始，每个区域包含两条线段，topline是数据的顺序绘制，baseline则反向绘制。</li><li>curve.areaEnd()<br>  表示当前区域的结束。</li><li>curve.lineStart()<br>  表示一条新的线段的开始，接下来会绘制多个点。</li><li>curve.lineEnd()<br>  表示当前线段的结束。</li><li>curve.point(x, y)<br>  在当前线段上根据给定的(x, y)坐标绘制一个新的点。</li></ul><h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//d3.symbol，默认绘制面积为64的圆形</span><br><span class="line">function symbol() &#123;</span><br><span class="line">    var type = constant$1(circle),</span><br><span class="line">        size = constant$1(64),</span><br><span class="line">        context = null;</span><br><span class="line"></span><br><span class="line">    function symbol() &#123;</span><br><span class="line">      var buffer;</span><br><span class="line">      if (!context) context = buffer = path();</span><br><span class="line">      type.apply(this, arguments).draw(context, +size.apply(this, arguments));</span><br><span class="line">      if (buffer) return context = null, buffer + &quot;&quot; || null;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置图形类型</span><br><span class="line">    symbol.type = function(_) &#123;</span><br><span class="line">      return arguments.length ? (type = typeof _ === &quot;function&quot; ? _ : constant$1(_), symbol) : type;</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置图形的面积</span><br><span class="line">    symbol.size = function(_) &#123;</span><br><span class="line">      return arguments.length ? (size = typeof _ === &quot;function&quot; ? _ : constant$1(+_), symbol) : size;</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置绘制上下文</span><br><span class="line">    symbol.context = function(_) &#123;</span><br><span class="line">      return arguments.length ? (context = _ == null ? null : _, symbol) : context;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return symbol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以内置的<code>circle</code>类型为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var circle = &#123;</span><br><span class="line">    //size是该圆形的面积</span><br><span class="line">    draw: function(context, size) &#123;</span><br><span class="line">      var r = Math.sqrt(size / pi$2);</span><br><span class="line">      context.moveTo(r, 0);</span><br><span class="line">      context.arc(0, 0, r, 0, tau$2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>若自定义type，则应该实现<code>draw</code>方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;shape模块提供各种形状的生成器，这些形状的产生是数据驱动的，通过控制输入数据来形成一种视觉的表现。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Chord</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-chord/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-chord/</id>
    <published>2016-09-06T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.460Z</updated>
    
    <content type="html"><![CDATA[<p>d3的chord部分用于将关系或网络流绘制成一种圆形布局。<br><a id="more"></a></p><p><img src="https://raw.githubusercontent.com/d3/d3-chord/master/img/chord.png" alt="chord图"></p><p>这部分内容分为两个方面，一方面是构造一个弦布局，另一方面是构造一个产生带状图形的生成器。</p><h2 id="chord"><a href="#chord" class="headerlink" title="chord"></a>chord</h2><p>chord的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">function chord() &#123;</span><br><span class="line">    var padAngle = 0,</span><br><span class="line">        sortGroups = null,</span><br><span class="line">        sortSubgroups = null,</span><br><span class="line">        sortChords = null;</span><br><span class="line"></span><br><span class="line">    function chord(matrix) &#123;</span><br><span class="line">      var n = matrix.length,</span><br><span class="line">          //matrix中每组数的总和</span><br><span class="line">          groupSums = [],</span><br><span class="line">          groupIndex = range(n),</span><br><span class="line">          subgroupIndex = [],</span><br><span class="line">          chords = [],</span><br><span class="line">          groups = chords.groups = new Array(n),</span><br><span class="line">          subgroups = new Array(n * n),</span><br><span class="line">          k,</span><br><span class="line">          x,</span><br><span class="line">          x0,</span><br><span class="line">          dx,</span><br><span class="line">          i,</span><br><span class="line">          j;</span><br><span class="line"></span><br><span class="line">      // 计算每组数的和以及所有数值的总和</span><br><span class="line">      k = 0, i = -1; while (++i &lt; n) &#123;</span><br><span class="line">        x = 0, j = -1; while (++j &lt; n) &#123;</span><br><span class="line">          x += matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        groupSums.push(x);</span><br><span class="line">        subgroupIndex.push(range(n));</span><br><span class="line">        k += x;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // sortGroups函数根据每组数据和的大小对groupIndex进行排序</span><br><span class="line">      if (sortGroups) groupIndex.sort(function(a, b) &#123;</span><br><span class="line">        return sortGroups(groupSums[a], groupSums[b]);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      // sortSubgroups函数根据每个数据大小在该组内进行索引的排序</span><br><span class="line">      if (sortSubgroups) subgroupIndex.forEach(function(d, i) &#123;</span><br><span class="line">        d.sort(function(a, b) &#123;</span><br><span class="line">          return sortSubgroups(matrix[i][a], matrix[i][b]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      // 计算除去padAngle之后的单位弧度（每单位数值对应的弧度）</span><br><span class="line">      k = max$1(0, tau$3 - padAngle * n) / k;</span><br><span class="line">      dx = k ? padAngle : tau$3 / n;</span><br><span class="line"></span><br><span class="line">      // 计算每个数据对应的startAngle和endAngle</span><br><span class="line">      x = 0, i = -1; while (++i &lt; n) &#123;</span><br><span class="line">        x0 = x, j = -1; while (++j &lt; n) &#123;</span><br><span class="line">          var di = groupIndex[i],</span><br><span class="line">              dj = subgroupIndex[di][j],</span><br><span class="line">              v = matrix[di][dj],</span><br><span class="line">              // startAngle</span><br><span class="line">              a0 = x,</span><br><span class="line">              // 计算endAngle</span><br><span class="line">              a1 = x += v * k;</span><br><span class="line">          //记录matrix中每个数据在弦图中的信息</span><br><span class="line">          subgroups[dj * n + di] = &#123;</span><br><span class="line">            index: di,</span><br><span class="line">            subindex: dj,</span><br><span class="line">            startAngle: a0,</span><br><span class="line">            endAngle: a1,</span><br><span class="line">            value: v</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录matrix中每组数据在弦图中的信息</span><br><span class="line">        groups[di] = &#123;</span><br><span class="line">          index: di,</span><br><span class="line">          startAngle: x0,</span><br><span class="line">          endAngle: x,</span><br><span class="line">          value: groupSums[di]</span><br><span class="line">        &#125;;</span><br><span class="line">        //考虑弦图中每组之间的间距</span><br><span class="line">        x += dx;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 产生source和target</span><br><span class="line">      i = -1; while (++i &lt; n) &#123;</span><br><span class="line">        j = i - 1; while (++j &lt; n) &#123;</span><br><span class="line">          var source = subgroups[j * n + i],</span><br><span class="line">              target = subgroups[i * n + j];</span><br><span class="line">          if (source.value || target.value) &#123;</span><br><span class="line">            //将value大的设置为source，小的设置为target</span><br><span class="line">            chords.push(source.value &lt; target.value</span><br><span class="line">                ? &#123;source: target, target: source&#125;</span><br><span class="line">                : &#123;source: source, target: target&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return sortChords ? chords.sort(sortChords) : chords;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置相邻组之间的间距，以弧度形式表示</span><br><span class="line">    chord.padAngle = function(_) &#123;</span><br><span class="line">      return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 对groupIndex进行排序</span><br><span class="line">    chord.sortGroups = function(_) &#123;</span><br><span class="line">      return arguments.length ? (sortGroups = _, chord) : sortGroups;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 对subgroupIndex进行排序</span><br><span class="line">    chord.sortSubgroups = function(_) &#123;</span><br><span class="line">      return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;</span><br><span class="line">    &#125;;</span><br><span class="line">    //对chords数组进行排序，影响的是chord的层叠顺序，两根弦重叠，重叠部分后面的会覆盖掉前面的</span><br><span class="line">    chord.sortChords = function(_) &#123;</span><br><span class="line">      return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords &amp;&amp; sortChords._;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return chord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>chord函数最终会得到一个包含多组<code>source</code>和<code>target</code>对象的数组以及<code>groups</code>数组，通过将该结果传递给<code>d3.arc</code>来绘制弦图外层的圆弧，而其内部的带状图则通过<code>d3.ribbon</code>来实现。</p><h2 id="ribbon"><a href="#ribbon" class="headerlink" title="ribbon"></a>ribbon</h2><p>用于绘制弦图中间部分表示各块之间联系的带状区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  function ribbon() &#123;</span><br><span class="line">    var source = defaultSource,</span><br><span class="line">        target = defaultTarget,</span><br><span class="line">        radius = defaultRadius$1,</span><br><span class="line">        startAngle = defaultStartAngle,</span><br><span class="line">        endAngle = defaultEndAngle,</span><br><span class="line">        context = null;</span><br><span class="line"></span><br><span class="line">    function ribbon() &#123;</span><br><span class="line">      var buffer,</span><br><span class="line">          argv = slice$5.call(arguments),</span><br><span class="line">          //source对象</span><br><span class="line">          s = source.apply(this, argv),</span><br><span class="line">          //target对象</span><br><span class="line">          t = target.apply(this, argv),</span><br><span class="line">          //带状图形中弧线的半径</span><br><span class="line">          sr = +radius.apply(this, (argv[0] = s, argv)),</span><br><span class="line"></span><br><span class="line">          sa0 = startAngle.apply(this, argv) - halfPi$2,</span><br><span class="line">          sa1 = endAngle.apply(this, argv) - halfPi$2,</span><br><span class="line">          sx0 = sr * cos(sa0),</span><br><span class="line">          sy0 = sr * sin(sa0),</span><br><span class="line">          tr = +radius.apply(this, (argv[0] = t, argv)),</span><br><span class="line">          ta0 = startAngle.apply(this, argv) - halfPi$2,</span><br><span class="line">          ta1 = endAngle.apply(this, argv) - halfPi$2;</span><br><span class="line">      //构造path对象，用于存储路径</span><br><span class="line">      if (!context) context = buffer = path();</span><br><span class="line">      //移动到startAngle对应的起始点</span><br><span class="line">      context.moveTo(sx0, sy0);</span><br><span class="line">      //向endAngle位置画弧线</span><br><span class="line">      context.arc(0, 0, sr, sa0, sa1);</span><br><span class="line">      //判断source和target是否是同个位置</span><br><span class="line">      if (sa0 !== ta0 || sa1 !== ta1) &#123; // TODO sr !== tr?</span><br><span class="line">        // 从source的endAngle位置绘制贝塞尔曲线至target的startAngle处</span><br><span class="line">        context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));</span><br><span class="line">        //target的startAngle绘制圆弧至endAngle位置</span><br><span class="line">        context.arc(0, 0, tr, ta0, ta1);</span><br><span class="line">      &#125;</span><br><span class="line">      //以(0, 0)为控制点绘制贝塞尔曲线至startAngle位置</span><br><span class="line">      context.quadraticCurveTo(0, 0, sx0, sy0);</span><br><span class="line">      context.closePath();</span><br><span class="line"></span><br><span class="line">      if (buffer) return context = null, buffer + &quot;&quot; || null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ribbon.radius = function(_) &#123;</span><br><span class="line">      return arguments.length ? (radius = typeof _ === &quot;function&quot; ? _ : constant$11(+_), ribbon) : radius;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ribbon.startAngle = function(_) &#123;</span><br><span class="line">      return arguments.length ? (startAngle = typeof _ === &quot;function&quot; ? _ : constant$11(+_), ribbon) : startAngle;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ribbon.endAngle = function(_) &#123;</span><br><span class="line">      return arguments.length ? (endAngle = typeof _ === &quot;function&quot; ? _ : constant$11(+_), ribbon) : endAngle;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ribbon.source = function(_) &#123;</span><br><span class="line">      return arguments.length ? (source = _, ribbon) : source;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ribbon.target = function(_) &#123;</span><br><span class="line">      return arguments.length ? (target = _, ribbon) : target;</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置当前路径上下文</span><br><span class="line">    ribbon.context = function(_) &#123;</span><br><span class="line">      return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return ribbon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;d3的chord部分用于将关系或网络流绘制成一种圆形布局。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>d3.js源码分析之Selections</title>
    <link href="http://arlendp.me/web/js/d3js-source-code-selections/"/>
    <id>http://arlendp.me/web/js/d3js-source-code-selections/</id>
    <published>2016-08-29T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.462Z</updated>
    
    <content type="html"><![CDATA[<p>在web开发中我们会花大量的时间用于dom的操作上，一般情况下我们会选择第三方库如jQuery来替代原生的方法，因为原生的方法在操作上会使代码大量重复冗余而不易操作。d3同样提供了一套自己的方法来很方便的对dom进行操作，像修改样式、注册时间等等都可以通过它来完成。<br><a id="more"></a></p><p>d3的selection主要用于直接对DOM进行操作，如设置属性、修改样式等等，同时它可以和data join（数据连接）这一强大的功能结合起来对元素和元素上绑定的数据进行操作。<br>selection中的方法计算后返回当前selection，这样可以进行方法的链式调用。由于通过这种方式调用方法会使得每行的代码很长，因此按照约定：若该方法返回的是<strong>当前的selection</strong>，则使用<strong>四个空格</strong>进行缩进；若方法返回的是<strong>新的selection</strong>，则使用<strong>两个空格</strong>进行缩进。</p><h2 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h2><p>元素的选择通过两种方法<code>select</code>和<code>selectAll</code>来实现，前者只返回第一个匹配的元素，而后者返回所有匹配元素。<br>由于之后所有的操作都是在selection上进行，而该对象则是通过Selection构造函数得到的，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Selection(groups, parents) &#123;</span><br><span class="line">    this._groups = groups;</span><br><span class="line">    this._parents = parents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，selection对象包含两个基本属性<code>_groups</code>和<code>_parents</code>，前者用于存储结点组，而后者则存储结点的父节点信息。</p><h3 id="selection-select-selector"><a href="#selection-select-selector" class="headerlink" title="selection.select(selector)"></a>selection.select(selector)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p = d3.selectAll(&apos;div&apos;)</span><br><span class="line">          .select(&apos;p&apos;);</span><br></pre></td></tr></table></figure><p>该方法对selection中的每个元素进行查找，选择其中第一个匹配selector的子元素，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Selection的select方法</span><br><span class="line"> * 通过select方法选择时，若不存在元素，则会在数组中将该位置留出（赋值为null）用于之后插入时使用。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function selection_select(select) &#123;</span><br><span class="line">    if (typeof select !== &quot;function&quot;) select = selector(select);</span><br><span class="line">    //当select是函数时，直接调用该函数，并依次对该函数传入data信息、当前的索引和当前的结点group，同时将函数的this设置为当前dom对象</span><br><span class="line">    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if ((node = group[i]) &amp;&amp; (subnode = select.call(node, node.__data__, i, group))) &#123;</span><br><span class="line">          //当node中有data信息时，node的子元素也添加该data信息</span><br><span class="line">            if (&quot;__data__&quot; in node) subnode.__data__ = node.__data__;</span><br><span class="line">                subgroup[i] = subnode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将父级的_parents属性作为子元素的_parents属性</span><br><span class="line">    return new Selection(subgroups, this._parents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若selector为选择器字符串时，则会先调用selector方法将其转化为函数，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function selector(selector) &#123;</span><br><span class="line">    return selector == null ? none$2 : function() &#123;</span><br><span class="line">        //只返回第一个选中元素</span><br><span class="line">        return this.querySelector(selector);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，其内部调用的是js的原生方法<code>querySelector</code>。<br>上述代码对select参数进行处理后，使得其转化为函数，在后来的循环中调用时，通过<code>select.call</code>进行调用，传入的参数依次为<strong>结点的<strong>data</strong>属性值，结点在该结点组中的索引，该结点组</strong>。<br>有以下几点值得注意：</p><ul><li>若结点中包含<code>__data__</code>属性则会对匹配的子元素也设置该属性。</li><li>通过select方法得到的新的selection的<code>_parents</code>值并不会改变。</li></ul><h3 id="selection-selectAll-selector"><a href="#selection-selectAll-selector" class="headerlink" title="selection.selectAll(selector)"></a>selection.selectAll(selector)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p = d3.selectAll(&apos;div&apos;)</span><br><span class="line">          .selectAll(&apos;p&apos;);</span><br></pre></td></tr></table></figure><p>该方法对selection中的每个元素进行查找，选择其中匹配selector的子元素，返回的selection中的元素根据其父结点进行对应的分组，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 对selection进行selectAll计算会改变selection结构，parents也会改变</span><br><span class="line"> */</span><br><span class="line">function selection_selectAll(select) &#123;</span><br><span class="line">    if (typeof select !== &quot;function&quot;) select = selectorAll(select);</span><br><span class="line">    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">        for (var group = groups[j], n = group.length, node, i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (node = group[i]) &#123;</span><br><span class="line">                subgroups.push(select.call(node, node.__data__, i, group));</span><br><span class="line">                parents.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Selection(subgroups, parents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码可以看出，对node调用select方法后，查找到的结果存入subgroups中，同时将node作为父结点存入parents数组中，使得结点与父结点一一对应，最终返回新的selection。</p><h3 id="selection-filter-filter"><a href="#selection-filter-filter" class="headerlink" title="selection.filter(filter)"></a>selection.filter(filter)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var red = d3.selectAll(&apos;p&apos;)</span><br><span class="line">            .filter(&apos;.red&apos;)</span><br></pre></td></tr></table></figure><p>将使得filter为true的元素构造成新的selection并返回，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//filter方法对当前selection进行过滤，保留满足条件的元素</span><br><span class="line">function selection_filter(match) &#123;</span><br><span class="line">    if (typeof match !== &quot;function&quot;) match = matcher$1(match);</span><br><span class="line">    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                if ((node = group[i]) &amp;&amp; match.call(node, node.__data__, i, group)) &#123;</span><br><span class="line">                subgroup.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Selection(subgroups, this._parents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若<code>match</code>不为函数，则通过<code>matcher$1</code>函数对其进行处理，其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var matcher = function(selector) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        //Element.matches(s)，如果元素能通过s选择器选择到则返回true；否则返回false</span><br><span class="line">        return this.matches(selector);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可看出<code>matcher</code>函数内部是调用原生的<code>Element.matches</code>方法实现。</p><h3 id="selection-merge-other-selection"><a href="#selection-merge-other-selection" class="headerlink" title="selection.merge(other_selection)"></a>selection.merge(other_selection)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var circle = svg.selectAll(&quot;circle&quot;).data(data) // UPDATE</span><br><span class="line">    .style(&quot;fill&quot;, &quot;blue&quot;);</span><br><span class="line"></span><br><span class="line">circle.exit().remove(); // EXIT</span><br><span class="line"></span><br><span class="line">circle.enter().append(&quot;circle&quot;) // ENTER</span><br><span class="line">    .style(&quot;fill&quot;, &quot;green&quot;)</span><br><span class="line">  .merge(circle) // ENTER + UPDATE</span><br><span class="line">    .style(&quot;stroke&quot;, &quot;black&quot;);</span><br></pre></td></tr></table></figure><p>该方法将两个selection进行合并成一个新的selection并返回，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function selection_merge(selection) &#123;</span><br><span class="line">    //新的selection的_.groups长度和groups0相同，合并时只在m范围内计算</span><br><span class="line">    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            //groups0数组大小不变，只有在group0[i]不存在，group1[i]存在时才选择group1[i]</span><br><span class="line">            if (node = group0[i] || group1[i]) &#123;</span><br><span class="line">                merge[i] = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若m1 &lt; m0，则将groups0剩余的复制过来</span><br><span class="line">    for (; j &lt; m0; ++j) &#123;</span><br><span class="line">      merges[j] = groups0[j];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Selection(merges, this._parents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法实际上相当于对this selection中的空元素进行填充。</p><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><p>在选择元素之后可以使用selection的方法来修改元素，如样式、属性等。</p><h3 id="selection-attr-name-value"><a href="#selection-attr-name-value" class="headerlink" title="selection.attr(name[, value])"></a>selection.attr(name[, value])</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p = d3.selectAll(&apos;p&apos;)</span><br><span class="line">            .attr(&apos;class&apos;, &apos;red&apos;);</span><br></pre></td></tr></table></figure><p>对selection中的元素以指定的name和value设置属性，并返回当前selection，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function selection_attr(name, value) &#123;</span><br><span class="line">    var fullname = namespace(name);</span><br><span class="line"></span><br><span class="line">    if (arguments.length &lt; 2) &#123;</span><br><span class="line">        //得到selection中第一个存在的元素</span><br><span class="line">        var node = this.node();</span><br><span class="line">        return fullname.local</span><br><span class="line">            ? node.getAttributeNS(fullname.space, fullname.local)</span><br><span class="line">            : node.getAttribute(fullname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.each((value == null</span><br><span class="line">        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === &quot;function&quot;</span><br><span class="line">        ? (fullname.local ? attrFunctionNS : attrFunction)</span><br><span class="line">        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若只有name参数时，则返回第一个存在的元素的name属性值，调用的是原生的<code>Element.getAttribute</code>方法。<br>当有两个参数时，调用<code>selection.each</code>方法对selection中的每个元素进行操作，其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function selection_each(callback) &#123;</span><br><span class="line">    for (var groups = this._groups, j = 0, m = groups.length; j &lt; m; ++j) &#123;</span><br><span class="line">        for (var group = groups[j], i = 0, n = group.length, node; i &lt; n; ++i) &#123;</span><br><span class="line">            if (node = group[i]) callback.call(node, node.__data__, i, group);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若value值为函数，则将name和value传入attrFunction函数中进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function attrFunction(name, value) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var v = value.apply(this, arguments);</span><br><span class="line">        if (v == null) this.removeAttribute(name);</span><br><span class="line">        else this.setAttribute(name, v);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>selection.each</code>方法中，将参数传入value函数中，根据value返回结果选择设置和删除属性操作。</p><h3 id="selection-classed-names-value"><a href="#selection-classed-names-value" class="headerlink" title="selection.classed(names[, value])"></a>selection.classed(names[, value])</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p = d3.selectAll(&apos;p&apos;)</span><br><span class="line">            .classed(&apos;red warn&apos;, true);</span><br></pre></td></tr></table></figure><p>对selection中的元素设置类名，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 当value为真值时，在所有元素类名中添加name；否则删除name</span><br><span class="line">function selection_classed(name, value) &#123;</span><br><span class="line">    var names = classArray(name + &quot;&quot;);</span><br><span class="line">    // 当只有name参数时，判断该selection对象的_groups里第一个存在的结点是否包含所有的name的类名，如果是则返回true；否则，返回false</span><br><span class="line">    if (arguments.length &lt; 2) &#123;</span><br><span class="line">        var list = classList(this.node()), i = -1, n = names.length;</span><br><span class="line">        while (++i &lt; n) if (!list.contains(names[i])) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.each((typeof value === &quot;function&quot;</span><br><span class="line">        ? classedFunction : value</span><br><span class="line">        ? classedTrue</span><br><span class="line">        : classedFalse)(names, value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>classArray</code>方法是将类名字符串拆分成数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将类名拆分成数组，如&apos;button button-warn&apos; =&gt; [&apos;button&apos;, &apos;button-warn&apos;]</span><br><span class="line">function classArray(string) &#123;</span><br><span class="line">    return string.trim().split(/^|\s+/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="selection-style-name-value-priority"><a href="#selection-style-name-value-priority" class="headerlink" title="selection.style(name[, value[, priority]])"></a>selection.style(name[, value[, priority]])</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p = d3.selectAll(&apos;p&apos;)</span><br><span class="line">            .style(&apos;color&apos;, &apos;red&apos;);</span><br></pre></td></tr></table></figure><p>该方法对selection中的元素设置样式，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 设置selection的样式，注意样式的单位问题</span><br><span class="line">function selection_style(name, value, priority) &#123;</span><br><span class="line">    var node;</span><br><span class="line">    return arguments.length &gt; 1</span><br><span class="line">        ? this.each((value == null</span><br><span class="line">              ? styleRemove : typeof value === &quot;function&quot;</span><br><span class="line">              ? styleFunction</span><br><span class="line">              : styleConstant)(name, value, priority == null ? &quot;&quot; : priority))</span><br><span class="line">        : window(node = this.node())</span><br><span class="line">            .getComputedStyle(node, null)</span><br><span class="line">            .getPropertyValue(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述代码可以看出，获取样式是通过<code>window.getComputedStyle(element).getPropertyValue(name)</code>来得到（该方法得到的值是只读的），而删除样式则是通过<code>element.style.removeProperty(name)</code>来实现，设置属性通过<code>element.style.setProperty(name, value)</code>来实现。</p><h3 id="selection-property-name-value"><a href="#selection-property-name-value" class="headerlink" title="selection.property(name[, value])"></a>selection.property(name[, value])</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var checkbox = d3.selectAll(&apos;input[type=checkbox]&apos;)</span><br><span class="line">                    .property(&apos;checked&apos;, &apos;checked&apos;);</span><br></pre></td></tr></table></figure><p>该方法设置一些特殊的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function selection_property(name, value) &#123;</span><br><span class="line">    return arguments.length &gt; 1</span><br><span class="line">        ? this.each((value == null</span><br><span class="line">            ? propertyRemove : typeof value === &quot;function&quot;</span><br><span class="line">            ? propertyFunction</span><br><span class="line">            : propertyConstant)(name, value))</span><br><span class="line">        : this.node()[name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function propertyRemove(name) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      delete this[name];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">function propertyConstant(name, value) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      this[name] = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function propertyFunction(name, value) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      var v = value.apply(this, arguments);</span><br><span class="line">      if (v == null) delete this[name];</span><br><span class="line">      else this[name] = v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部通过直接修改元素的属性来实现。</p><h3 id="selection-text-value"><a href="#selection-text-value" class="headerlink" title="selection.text([value])"></a>selection.text([value])</h3><p>该方法对selection中的所有元素设置文本内容，同时会替换掉元素中的子元素，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function textRemove() &#123;</span><br><span class="line">    this.textContent = &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function textConstant(value) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      this.textContent = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function textFunction(value) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      var v = value.apply(this, arguments);</span><br><span class="line">      this.textContent = v == null ? &quot;&quot; : v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 设置元素的textContent属性，该属性返回的是元素内的纯文本内容，不包含结点标签（但包含标签内的文本）</span><br><span class="line">function selection_text(value) &#123;</span><br><span class="line">    return arguments.length</span><br><span class="line">        ? this.each(value == null</span><br><span class="line">            ? textRemove : (typeof value === &quot;function&quot;</span><br><span class="line">            ? textFunction</span><br><span class="line">            : textConstant)(value))</span><br><span class="line">        : this.node().textContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是通过<code>element.textContent</code>方法来获取和修改文本内容。</p><h3 id="selection-html-value"><a href="#selection-html-value" class="headerlink" title="selection.html([value])"></a>selection.html([value])</h3><p>对selection中的所有元素设置innerHTML。方法同上述<code>selection.text</code>类似，只是通过<code>element.innerHTML</code>来修改元素内的所有内容。</p><h3 id="selection-append-type"><a href="#selection-append-type" class="headerlink" title="selection.append(type)"></a>selection.append(type)</h3><p>对selection中的元素添加新的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * selection的append方法</span><br><span class="line"> * 该方法返回新的Selection对象，</span><br><span class="line"> */</span><br><span class="line">function selection_append(name) &#123;</span><br><span class="line">    var create = typeof name === &quot;function&quot; ? name : creator(name);</span><br><span class="line">    return this.select(function() &#123;</span><br><span class="line">        //arguments是传入当前匿名函数的参数</span><br><span class="line">        return this.appendChild(create.apply(this, arguments));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function creatorInherit(name) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        //ownerDocument返回当前document对象</span><br><span class="line">        var document = this.ownerDocument,</span><br><span class="line">            uri = this.namespaceURI;</span><br><span class="line">        return uri === xhtml &amp;&amp; document.documentElement.namespaceURI === xhtml</span><br><span class="line">            ? document.createElement(name)//创建dom对象</span><br><span class="line">            : document.createElementNS(uri, name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法中调用到了<code>selection.select</code>方法，由于<code>element.appendChild</code>方法返回的是该子结点，因此返回的新的selection包含的是所有添加的子结点。</p><h3 id="selection-insert-type-before"><a href="#selection-insert-type-before" class="headerlink" title="selection.insert(type, before)"></a>selection.insert(type, before)</h3><p>对selection中的元素插入新的元素，同上述<code>selection.append</code>方法类似，只是内部使用<code>element.insertBefore</code>方法实现。</p><h3 id="selection-sort-compare"><a href="#selection-sort-compare" class="headerlink" title="selection.sort(compare)"></a>selection.sort(compare)</h3><p>根据<code>compare</code>函数对selection中的元素进行排序，排好序后按照排序结果对dom进行排序，返回排序后新创建的selection对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function selection_sort(compare) &#123;</span><br><span class="line">    if (!compare) compare = ascending$2;</span><br><span class="line"></span><br><span class="line">    function compareNode(a, b) &#123;</span><br><span class="line">      // 比较结点的data大小</span><br><span class="line">      return a &amp;&amp; b ? compare(a.__data__, b.__data__) : !a - !b;</span><br><span class="line">    &#125;</span><br><span class="line">    // copy一份selection中的_groups包含的结点</span><br><span class="line">    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (node = group[i]) &#123;</span><br><span class="line">                sortgroup[i] = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 调用array的sort方法</span><br><span class="line">        sortgroup.sort(compareNode);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Selection(sortgroups, this._parents).order();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递增</span><br><span class="line">function ascending$2(a, b) &#123;</span><br><span class="line">    return a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若没有compare参数，则默认以递增的方式排序。同时排序是首先比较元素中的<code>__data__</code>属性值的大小，对selection排好序后调用order方法。</p><h3 id="selection-sort-compare-1"><a href="#selection-sort-compare-1" class="headerlink" title="selection.sort(compare)"></a>selection.sort(compare)</h3><p>按照selection中每组内元素的顺序对dom进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 对dom结点进行排序</span><br><span class="line">function selection_order() &#123;</span><br><span class="line">    for (var groups = this._groups, j = -1, m = groups.length; ++j &lt; m;) &#123;</span><br><span class="line">        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i &gt;= 0;) &#123;</span><br><span class="line">            if (node = group[i]) &#123;</span><br><span class="line">                // 将node移至next的前面，并将node赋值给next</span><br><span class="line">                if (next &amp;&amp; next !== node.nextSibling) next.parentNode.insertBefore(node, next);</span><br><span class="line">                next = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="连接数据"><a href="#连接数据" class="headerlink" title="连接数据"></a>连接数据</h2><p>连接数据是将数据绑定到selection对象上，实际上是将数据存储到<code>__data__</code>属性中，这样之后对selection的操作过程中便可以直接使用绑定好的数据。主要要理解<code>update</code>、<code>enter</code>和<code>exit</code>，可参考文章<a href="https://bost.ocks.org/mike/join/" target="_blank" rel="noopener">Thinking With Joins</a>。</p><h3 id="selection-data-data-key"><a href="#selection-data-data-key" class="headerlink" title="selection.data([data[, key]])"></a>selection.data([data[, key]])</h3><p>该方法将指定的data数组绑定到选中的元素上，返回的selection包含成功绑定数据的元素，也叫做<code>updata selection</code>，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function selection_data(value, key) &#123;</span><br><span class="line">    //当value为假值时，将selection所有元素的__data__属性以数组形式返回</span><br><span class="line">    if (!value) &#123;</span><br><span class="line">      data = new Array(this.size()), j = -1;</span><br><span class="line">      this.each(function(d) &#123; data[++j] = d; &#125;);</span><br><span class="line">      return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var bind = key ? bindKey : bindIndex,</span><br><span class="line">        parents = this._parents,</span><br><span class="line">        groups = this._groups;</span><br><span class="line"></span><br><span class="line">    if (typeof value !== &quot;function&quot;) value = constant$4(value);</span><br><span class="line"></span><br><span class="line">    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">      var parent = parents[j],</span><br><span class="line">          group = groups[j],</span><br><span class="line">          groupLength = group.length,</span><br><span class="line">          data = value.call(parent, parent &amp;&amp; parent.__data__, j, parents),</span><br><span class="line">          dataLength = data.length,</span><br><span class="line">          enterGroup = enter[j] = new Array(dataLength),</span><br><span class="line">          updateGroup = update[j] = new Array(dataLength),</span><br><span class="line">          exitGroup = exit[j] = new Array(groupLength);</span><br><span class="line"></span><br><span class="line">      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);</span><br><span class="line"></span><br><span class="line">      // 对enter结点设置_next属性，存储其索引之后的第一个update结点</span><br><span class="line">      for (var i0 = 0, i1 = 0, previous, next; i0 &lt; dataLength; ++i0) &#123;</span><br><span class="line">        if (previous = enterGroup[i0]) &#123;</span><br><span class="line">          if (i0 &gt;= i1) i1 = i0 + 1;</span><br><span class="line">          while (!(next = updateGroup[i1]) &amp;&amp; ++i1 &lt; dataLength);</span><br><span class="line">          previous._next = next || null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将enter和exit存入update selection的属性中</span><br><span class="line">    update = new Selection(update, parents);</span><br><span class="line">    update._enter = enter;</span><br><span class="line">    update._exit = exit;</span><br><span class="line">    return update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上述代码可以看到，对每组group绑定的是相同的data数据。<br>当没有key参数时，绑定数据使用的是<code>bindIndex</code>方法，按照索引一次绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function bindIndex(parent, group, enter, update, exit, data) &#123;</span><br><span class="line">    var i = 0,</span><br><span class="line">        node,</span><br><span class="line">        groupLength = group.length,</span><br><span class="line">        dataLength = data.length;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 将data数据绑定到node，并将该node存入update数组中</span><br><span class="line">     * 将剩余的data数据存入enter数组中</span><br><span class="line">     */</span><br><span class="line">    for (; i &lt; dataLength; ++i) &#123;</span><br><span class="line">      if (node = group[i]) &#123;</span><br><span class="line">        node.__data__ = data[i];</span><br><span class="line">        update[i] = node;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        enter[i] = new EnterNode(parent, data[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将剩余的node存入exit数组中</span><br><span class="line">    for (; i &lt; groupLength; ++i) &#123;</span><br><span class="line">      if (node = group[i]) &#123;</span><br><span class="line">        exit[i] = node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>若含有key参数，则调用<code>bindKey</code>方法来绑定数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function bindKey(parent, group, enter, update, exit, data, key) &#123;</span><br><span class="line">    var i,</span><br><span class="line">        node,</span><br><span class="line">        nodeByKeyValue = &#123;&#125;,</span><br><span class="line">        groupLength = group.length,</span><br><span class="line">        dataLength = data.length,</span><br><span class="line">        keyValues = new Array(groupLength),</span><br><span class="line">        keyValue;</span><br><span class="line"></span><br><span class="line">    // 对group中每个结点计算keyValue，如果之后的结点含有与前面结点相同的keyValue则将该结点存入exit数组中</span><br><span class="line">    for (i = 0; i &lt; groupLength; ++i) &#123;</span><br><span class="line">      if (node = group[i]) &#123;</span><br><span class="line">        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);</span><br><span class="line">        if (keyValue in nodeByKeyValue) &#123;</span><br><span class="line">          exit[i] = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          nodeByKeyValue[keyValue] = node;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对每一个data计算keyValue，如果该keyValue已存在nodeByKeyValue数组中，则将其对应的node存入update数组且绑定data数据；否则将data存入enter中</span><br><span class="line">    for (i = 0; i &lt; dataLength; ++i) &#123;</span><br><span class="line">      keyValue = keyPrefix + key.call(parent, data[i], i, data);</span><br><span class="line">      if (node = nodeByKeyValue[keyValue]) &#123;</span><br><span class="line">        update[i] = node;</span><br><span class="line">        node.__data__ = data[i];</span><br><span class="line">        nodeByKeyValue[keyValue] = null;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        enter[i] = new EnterNode(parent, data[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将剩余的没有绑定数据的结点存入exit数组</span><br><span class="line">    for (i = 0; i &lt; groupLength; ++i) &#123;</span><br><span class="line">      if ((node = group[i]) &amp;&amp; (nodeByKeyValue[keyValues[i]] === node)) &#123;</span><br><span class="line">        exit[i] = node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="selection-enter"><a href="#selection-enter" class="headerlink" title="selection.enter()"></a>selection.enter()</h3><p>返回selections中的enter selection，即<code>selection._enter</code>的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sparse(update) &#123;</span><br><span class="line">    return new Array(update.length);</span><br><span class="line">  &#125;</span><br><span class="line">// selection的enter方法</span><br><span class="line">function selection_enter() &#123;</span><br><span class="line">    return new Selection(this._enter || this._groups.map(sparse), this._parents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若selection没有<code>_enter</code>属性，即没有进行过<code>data</code>操作，则创建空的数组。</p><h3 id="selection-exit"><a href="#selection-exit" class="headerlink" title="selection.exit()"></a>selection.exit()</h3><p>返回selection中的exit selection，即<code>selection._exit</code>的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function selection_exit() &#123;</span><br><span class="line">    return new Selection(this._exit || this._groups.map(sparse), this._parents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="selection-datum-value"><a href="#selection-datum-value" class="headerlink" title="selection.datum([value])"></a>selection.datum([value])</h3><p>对selection中的每个元素设置绑定数据，该方法并不会影响到<code>enter</code>和<code>exit</code>的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function selection_datum(value) &#123;</span><br><span class="line">    return arguments.length</span><br><span class="line">        ? this.property(&quot;__data__&quot;, value)</span><br><span class="line">        : this.node().__data__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见其调用<code>selection.property</code>方法来设置<code>__data__</code>属性。<br>经常会使用该方法来进行HTML5 data属性的访问，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selection.datum(function() &#123;return this.dataset&#125;);</span><br></pre></td></tr></table></figure></p><p><code>element.dataset</code>是原生方法，返回的是元素绑定的所有data属性。</p><h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><h3 id="selection-on-typenames-listener-capture"><a href="#selection-on-typenames-listener-capture" class="headerlink" title="selection.on(typenames[, listener[, capture]])"></a>selection.on(typenames[, listener[, capture]])</h3><p>该方法用于对selection中的元素添加或者移除事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function selection_on(typename, value, capture) &#123;</span><br><span class="line">    var typenames = parseTypenames$1(typename + &quot;&quot;), i, n = typenames.length, t;</span><br><span class="line">    // 如果只有typename参数，根据type和name值来找到selection中第一个存在的元素的__on属性中对应的value值。</span><br><span class="line">    if (arguments.length &lt; 2) &#123;</span><br><span class="line">      var on = this.node().__on;</span><br><span class="line">      if (on) for (var j = 0, m = on.length, o; j &lt; m; ++j) &#123;</span><br><span class="line">        for (i = 0, o = on[j]; i &lt; n; ++i) &#123;</span><br><span class="line">          if ((t = typenames[i]).type === o.type &amp;&amp; t.name === o.name) &#123;</span><br><span class="line">            return o.value;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果value为真值，则添加事件；否则移除事件。</span><br><span class="line">    on = value ? onAdd : onRemove;</span><br><span class="line">    if (capture == null) capture = false;</span><br><span class="line">    for (i = 0; i &lt; n; ++i) this.each(on(typenames[i], value, capture));</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>首先是对typename参数进行处理，使用的是<code>parseTypenames</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 对typenames根据空格来划分成数组，并根据分离后的字符串中的&apos;.&apos;来将该字符串分割为type和name部分，如：&apos;click.foo click.bar&apos; =&gt; [&#123;type: &apos;click&apos;, name: &apos;foo&apos;&#125;, &#123;type: &apos;click&apos;, name: &apos;bar&apos;&#125;]</span><br><span class="line">function parseTypenames$1(typenames) &#123;</span><br><span class="line">    return typenames.trim().split(/^|\s+/).map(function(t) &#123;</span><br><span class="line">      var name = &quot;&quot;, i = t.indexOf(&quot;.&quot;);</span><br><span class="line">      if (i &gt;= 0) name = t.slice(i + 1), t = t.slice(0, i);</span><br><span class="line">      return &#123;type: t, name: name&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据value是否为真值来选择添加或者移除事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 添加事件函数</span><br><span class="line">function onAdd(typename, value, capture) &#123;</span><br><span class="line">    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;</span><br><span class="line">    return function(d, i, group) &#123;</span><br><span class="line">        var on = this.__on, o, listener = wrap(value, i, group);</span><br><span class="line">        if (on) for (var j = 0, m = on.length; j &lt; m; ++j) &#123;</span><br><span class="line">            // 如果新事件的type和name和之前已绑定的事件相同，则移除之前的事件并绑定新的事件</span><br><span class="line">            if ((o = on[j]).type === typename.type &amp;&amp; o.name === typename.name) &#123;</span><br><span class="line">                this.removeEventListener(o.type, o.listener, o.capture);</span><br><span class="line">                this.addEventListener(o.type, o.listener = listener, o.capture = capture);</span><br><span class="line">                o.value = value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加事件，并将事件信息存入selection.__on属性中</span><br><span class="line">        this.addEventListener(typename.type, listener, capture);</span><br><span class="line">        o = &#123;type: typename.type, name: typename.name, value: value, listener: listener, capture: capture&#125;;</span><br><span class="line">        if (!on) this.__on = [o];</span><br><span class="line">        else on.push(o);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 移除事件函数</span><br><span class="line">function onRemove(typename) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var on = this.__on;</span><br><span class="line">        if (!on) return;</span><br><span class="line">        for (var j = 0, i = -1, m = on.length, o; j &lt; m; ++j) &#123;</span><br><span class="line">            if (o = on[j], (!typename.type || o.type === typename.type) &amp;&amp; o.name === typename.name) &#123;</span><br><span class="line">            //对结点移除事件</span><br><span class="line">            this.removeEventListener(o.type, o.listener, o.capture);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //修改结点的__on属性值</span><br><span class="line">                on[++i] = o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (++i) on.length = i;</span><br><span class="line">        //on为空则删除__on属性</span><br><span class="line">        else delete this.__on;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="selection-dispatch-type-parameters"><a href="#selection-dispatch-type-parameters" class="headerlink" title="selection.dispatch(type[, parameters])"></a>selection.dispatch(type[, parameters])</h3><p>对selection中的元素分派指定类型的自定义事件，其中parameters可能包含以下内容：</p><ul><li>bubbles：设置为true表示事件可以冒泡</li><li>cancelable：设置为true表示事件可以被取消</li><li>detail：绑定到事件上的自定义数据<br>源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//分派事件</span><br><span class="line">function selection_dispatch(type, params) &#123;</span><br><span class="line">    return this.each((typeof params === &quot;function&quot;</span><br><span class="line">        ? dispatchFunction</span><br><span class="line">        : dispatchConstant)(type, params));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dispatchConstant(type, params) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      return dispatchEvent(this, type, params);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dispatchFunction(type, params) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      return dispatchEvent(this, type, params.apply(this, arguments));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>dispatchEvent</code>函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建自定义事件并分派给指定元素</span><br><span class="line">function dispatchEvent(node, type, params) &#123;</span><br><span class="line">    var window$$ = window(node),</span><br><span class="line">        event = window$$.CustomEvent;</span><br><span class="line"></span><br><span class="line">    if (event) &#123;</span><br><span class="line">      event = new event(type, params);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //该方法已被废弃</span><br><span class="line">        event = window$$.document.createEvent(&quot;Event&quot;);</span><br><span class="line">        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;</span><br><span class="line">        else event.initEvent(type, false, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-event"><a href="#d3-event" class="headerlink" title="d3.event"></a>d3.event</h3><p>存储当前事件，在调用事件监听器的时候设置，处理函数执行完毕后重置，可以获取其中包含的事件信息如：<code>event.pageX</code>。</p><h3 id="d3-customEvent-event-listener-that-arguments"><a href="#d3-customEvent-event-listener-that-arguments" class="headerlink" title="d3.customEvent(event, listener[, that[, arguments]])"></a>d3.customEvent(event, listener[, that[, arguments]])</h3><p>该方法调用指定的监听器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//调用指定的监听器</span><br><span class="line">function customEvent(event1, listener, that, args) &#123;</span><br><span class="line">    //记录当前事件</span><br><span class="line">    var event0 = exports.event;</span><br><span class="line">    event1.sourceEvent = exports.event;</span><br><span class="line">    exports.event = event1;</span><br><span class="line">    try &#123;</span><br><span class="line">        return listener.apply(that, args);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //监听器执行完后恢复事件</span><br><span class="line">        exports.event = event0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="d3-mouse-container"><a href="#d3-mouse-container" class="headerlink" title="d3.mouse(container)"></a>d3.mouse(container)</h3><p>返回当前当前事件相对于指定容器的x和y坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function mouse(node) &#123;</span><br><span class="line">    var event = sourceEvent();</span><br><span class="line">    //如果是触摸事件，返回Touch对象</span><br><span class="line">    if (event.changedTouches) event = event.changedTouches[0];</span><br><span class="line">    return point$5(node, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>point$5</code>方法用于计算坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function point$5(node, event) &#123;</span><br><span class="line">    //若node是svg元素，则获取svg容器</span><br><span class="line">    var svg = node.ownerSVGElement || node;</span><br><span class="line"></span><br><span class="line">    if (svg.createSVGPoint) &#123;</span><br><span class="line">      //创建SVGPoint对象</span><br><span class="line">      var point = svg.createSVGPoint();</span><br><span class="line">      //将事件相对客户端的x和y坐标赋值给point对象</span><br><span class="line">      point.x = event.clientX, point.y = event.clientY;</span><br><span class="line">      //进行坐标转换</span><br><span class="line">      point = point.matrixTransform(node.getScreenCTM().inverse());</span><br><span class="line">      return [point.x, point.y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var rect = node.getBoundingClientRect();</span><br><span class="line">    //返回event事件相对于容器的坐标</span><br><span class="line">    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>用于selection的一些高级操作。</p><h3 id="selection-each-function"><a href="#selection-each-function" class="headerlink" title="selection.each(function)"></a>selection.each(function)</h3><p>为每一个选中的元素调用指定的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//selection的each方法</span><br><span class="line">function selection_each(callback) &#123;</span><br><span class="line"></span><br><span class="line">    for (var groups = this._groups, j = 0, m = groups.length; j &lt; m; ++j) &#123;</span><br><span class="line">      for (var group = groups[j], i = 0, n = group.length, node; i &lt; n; ++i) &#123;</span><br><span class="line">        //通过call方式调用回调函数</span><br><span class="line">        if (node = group[i]) callback.call(node, node.__data__, i, group);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="selection-call-function-arguments…"><a href="#selection-call-function-arguments…" class="headerlink" title="selection.call(function[, arguments…])"></a>selection.call(function[, arguments…])</h3><p>将selection和其他参数传入指定函数中执行，并返回当前selection，这和直接链式调用<code>function(selection)</code>相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function selection_call() &#123;</span><br><span class="line">    var callback = arguments[0];</span><br><span class="line">    arguments[0] = this;</span><br><span class="line">    callback.apply(null, arguments);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>d3的局部变量可以定义与data独立开来的局部状态，它的作用域是dom元素。<br>其构造函数和原型方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Local() &#123;</span><br><span class="line">    this._ = &quot;@&quot; + (++nextId).toString(36);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Local.prototype = local.prototype = &#123;</span><br><span class="line">    constructor: Local,</span><br><span class="line">    get: function(node) &#123;</span><br><span class="line">      var id = this._;</span><br><span class="line">      while (!(id in node)) if (!(node = node.parentNode)) return;</span><br><span class="line">      return node[id];</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(node, value) &#123;</span><br><span class="line">      return node[this._] = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: function(node) &#123;</span><br><span class="line">      return this._ in node &amp;&amp; delete node[this._];</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: function() &#123;</span><br><span class="line">      return this._;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在web开发中我们会花大量的时间用于dom的操作上，一般情况下我们会选择第三方库如jQuery来替代原生的方法，因为原生的方法在操作上会使代码大量重复冗余而不易操作。d3同样提供了一套自己的方法来很方便的对dom进行操作，像修改样式、注册时间等等都可以通过它来完成。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="D3.js" scheme="http://arlendp.me/tags/D3-js/"/>
    
  </entry>
  
  <entry>
    <title>javascript正则表达式</title>
    <link href="http://arlendp.me/web/js/javascript-regex/"/>
    <id>http://arlendp.me/web/js/javascript-regex/</id>
    <published>2016-04-07T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.465Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式常用作检索、匹配或者替换文本，它是一种文本模式匹配的方法，在我们对复杂文本进行操作时，使用正则表达式会极大的简化我们的操作。本文将介绍正则表达式对象和匹配规则。<br><a id="more"></a></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>正则表达式是一种表示文本模式的方法，常用于匹配文本，例如email地址的验证等等，js中的正则表达式是Perl 5的子集。</p><p>正则表达式有两种写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc/</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>上述两种写法的主要区别在于新建正则表达式的时间，前者是在编译时完成，后者则是在运行时完成。</p><h2 id="2-正则表达式对象"><a href="#2-正则表达式对象" class="headerlink" title="2. 正则表达式对象"></a>2. 正则表达式对象</h2><h3 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1 属性"></a>2.1 属性</h3><p>正则表达式对象的属性主要有5个：</p><ul><li>与修饰符相关，都返回布尔值并且都是只读属性：<ul><li>ignoreCase：表示是否设置了i修饰符</li><li>global：表示是否设置了g修饰符</li><li>multiline：表示是否设置m修饰符</li></ul></li><li>与修饰符无关：<ul><li>lastIndex：返回下一次开始搜索的位置，<strong>且只在设置了g修饰符时才有意义</strong>。</li><li>source：返回正则表达式相应的字符串形式。</li></ul></li></ul><h3 id="2-2-方法（正则表达式）"><a href="#2-2-方法（正则表达式）" class="headerlink" title="2.2 方法（正则表达式）"></a>2.2 方法（正则表达式）</h3><ul><li><p><code>test()</code></p><ul><li>test接收一个字符串用于验证该字符串能否被匹配，结果返回布尔值。</li><li>若正则表达式字符串为空，则能匹配所有字符串。</li></ul></li><li><p><code>exec()</code></p><ul><li>exec接收一个字符串并且以数组的形式返回匹配结果，含有每一个匹配成功的子字符串，若匹配失败则返回null。</li><li>返回的数组含有两个属性：<ul><li><code>input</code>：表示原字符串</li><li><code>index</code>：表示模式匹配成功的开始位置</li></ul></li></ul></li></ul><h3 id="2-3-方法（字符串）"><a href="#2-3-方法（字符串）" class="headerlink" title="2.3 方法（字符串）"></a>2.3 方法（字符串）</h3><ul><li>match()：返回一个数组，成员是所有匹配的子字符串。<ul><li>该方法与正则表达式的<code>exec</code>方法类似</li><li>如果正则表达式带有<code>g</code>修饰符，该方法会返回所有匹配的结果，而<code>exec</code>则不会。</li><li>设置<code>lastIndex</code>属性对其无效。</li></ul></li><li>search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。若不匹配则返回-1.（<strong>忽略g修饰符和lastIndex属性</strong>）。</li><li>replace()：按照给定的正则表达式进行替换，返回替换后的字符串。<ul><li>有两个参数，第一个是搜索的模式，第二个是替换的内容。</li><li>搜索模式如果不加g修饰符，则替换第一个匹配的结果，否则替换所有的匹配结果。</li><li>该方法的第二个参数可以使用<code>$</code>来指代所替换的内容。<ul><li><code>$&amp;</code> 指代匹配的子字符串。</li><li><code>$\</code> 指代匹配结果前面的文本。</li><li><code>$&#39;</code> 指代匹配结果后面的文本。</li><li><code>$n</code> 指代匹配成功的第n组内容，n是从1开始的自然数。</li><li><code>$$</code> 指代美元符号$。</li></ul></li></ul></li></ul><ul><li>split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li></ul><h3 id="2-4-匹配规则"><a href="#2-4-匹配规则" class="headerlink" title="2.4 匹配规则"></a>2.4 匹配规则</h3><ul><li>字面量字符：字符直接表示其字面的含义，如/a/、/word/。</li><li>元字符：表示特殊含义<ul><li><code>.</code>字符<ul><li>能匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</li><li>但是只能匹配一个字符。</li></ul></li><li>位置字符<ul><li><code>^</code>字符：表示字符串的开始位置</li><li><code>$</code>字符：表示字符串的结束位置</li></ul></li><li>选择符<ul><li><code>|</code>字符：表示关系”或“。<strong>会包括前后的多个字符</strong><ul><li>重复类：用于精确设置匹配次数，使用<code>{}</code>表示。<code>{n}</code>表示重复n次，<code>{n,}</code>表示不少于n次，<code>{m,n}</code>表示重复m~n次。<strong>只匹配前一个字符</strong></li></ul></li></ul></li></ul></li><li>量词符：用于设置模式匹配的次数，同样只匹配前一个字符：<ul><li><code>?</code>等同于<code>{0,1}</code></li><li><code>*</code>等同于<code>{0,}</code></li><li><code>+</code>等同于<code>{1,}</code></li></ul></li><li>贪婪模式：匹配到下一个字符不满足匹配规则为止。<ul><li>所有的量词符后面加上<code>?</code>即可变为非贪婪模式。</li></ul></li><li>字符类：表示一系列字符中只要匹配一个就可以，所有可供选择的字符都放在方括号中。如<code>[abc]</code>：表示匹配a、b、c三个字母中的任意一个。<ul><li>脱字符（^）<ul><li><code>[^abc]</code>：表示除了abc外所有字符都可以匹配。</li><li><code>[^]</code>可以匹配所有字符，比<code>.</code>匹配更强。</li><li><code>^</code>字符只有在字符类的第一个位置才有意义，否则直接就是字面含义。</li></ul></li><li>连字符（-）<ul><li>对于连续序列的字符可用（-）来简写。</li><li><code>[a-z]</code>表示所有的小写字母。</li><li><code>-</code>字符若不在方括号之中则代表字面含义。</li><li>并且连字符必须在头尾两个字符之间才有特殊含义，否则只是字面含义。</li></ul></li></ul></li><li>转义符<ul><li>在正则表达式中有些特殊含义的字符，如果要匹配它们本身则需要在前面加上反斜杠。</li><li>正则表达式中需要斜杠转义的一共有以下12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\\</code>。</li><li>注意若是通过RegExp构造函数生成正则对象，转义时需要使用双斜杠<code>\\</code>，因为字符串内部会先转义一次。</li></ul></li><li>修饰符<ul><li><code>g</code>修饰符<ul><li>默认情况下，第一次匹配成功之后正则表达式就停止匹配，若有g修饰符则会匹配所有符合条件的结果，主要用于搜索和替换。</li></ul></li><li><code>i</code>修饰符<ul><li>表示忽略大小写。</li></ul></li><li><code>m</code>修饰符<ul><li>表示多行模式，会修改<code>^</code>、<code>$</code>的行为，这两个字符默认情况下是作为位置字符来匹配字符串的开始和结束位置。当加上m修饰符时会匹配行首和行尾，即会识别换行符（\n）。</li><li><code>/^bc/m.test(&quot;a\nbc&quot;)</code>返回true。</li></ul></li></ul></li><li>预定义模式：指常见模式的一些简写方式<ul><li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li><li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li><li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li><li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li><li><code>\s</code> 匹配空格（包括制表符、空格符、断行符等），相等于<code>[\t\r\n\v\f]</code>。</li><li><code>\S</code> 匹配非空格的字符，相当于<code>[^\t\r\n\v\f]</code>。</li><li><code>\b</code> 匹配词的边界，即该词单独存在。</li><li><code>\B</code> 匹配非词边界，即在词的内部。</li></ul></li><li><p>特殊字符：正则表达式中表示一些不能打印的字符。</p><blockquote><p>\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。<br>  [\b] 匹配退格键(U+0008)，不要与\b混淆。<br>  \n 匹配换行键。<br>  \r 匹配回车键。<br>  \t 匹配制表符tab（U+0009）。<br>  \v 匹配垂直制表符（U+000B）。<br>  \f 匹配换页符（U+000C）。<br>  \0 匹配null字符（U+0000）。<br>  \xhh 匹配一个以两位十六进制数表示的字符。<br>  \uhhhh 匹配一个以四位十六进制数表示的unicode字符。</p></blockquote></li><li><p>组匹配</p><ul><li>正则表达式中通过括号表示分组匹配。</li><li>使用组匹配时不宜同时使用g修饰符，否则match方法不会捕获分组内容。如：<code>&quot;abcabc&quot;.match(/(.)b(.)/);//返回[&#39;abc&#39;, &#39;a&#39;, &#39;c&#39;]</code>而<code>&quot;abcabc&quot;.march(/(.)b(.)/g)返回[&#39;abc&#39;, &#39;abc&#39;]</code>。</li><li>组匹配中通过<code>\数字</code>可以引用括号匹配的内容。如：<code>/(.)b(.)\1\2/.test(&#39;abcabc&#39;) // \1表示第一个括号匹配结果即a， \2表示第二个括号匹配结果即c</code>。</li></ul></li><li>非捕获组<ul><li><code>(?:x)</code>表示不返回该组匹配的内容，为了不占用组匹配。</li><li>如：<code>&quot;abc&quot;.match(/(?:.)b(.)/)</code>返回[“abc”, “c”]。</li></ul></li><li>先行断言<ul><li><code>x(?=y)</code>表示x只有在y的前面才匹配，并且匹配结果中不会将y计入。</li><li>如：<code>&quot;abc&quot;.match(/b(?=c)/);</code>返回[“b”]。</li></ul></li><li>先行否定断言<ul><li>x只有不在y前面才会匹配。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式常用作检索、匹配或者替换文本，它是一种文本模式匹配的方法，在我们对复杂文本进行操作时，使用正则表达式会极大的简化我们的操作。本文将介绍正则表达式对象和匹配规则。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习笔记</title>
    <link href="http://arlendp.me/web/js/js-study-notes/"/>
    <id>http://arlendp.me/web/js/js-study-notes/</id>
    <published>2016-03-03T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.468Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对《javascript权威指南》这本书中的知识点的总结。<br><a id="more"></a></p><h2 id="1-词法结构"><a href="#1-词法结构" class="headerlink" title="1. 词法结构"></a>1. 词法结构</h2><ul><li>js标识符必须以字母、下划线（<code>_</code>）或美元符（<code>$</code>）开始，后续字符可以是字母、数字、下划线或美元符。</li><li>当缺少分号时，js并不是在所有换行处填补分号，而是在缺少分号就无法正确解析代码的时候才会填补分号。但有两个例外：<ul><li>当<code>return</code>、<code>break</code>和<code>continue</code>语句后面紧接着换行时，js会在换行处添加分号。</li><li>当涉及到<code>++</code>和<code>--</code>符号时，若运算符作为后缀使用，应和表达式在同一行，若此时换行，js会在行尾填补分号，运算符会作为下一行代码的前缀运算符。</li></ul></li></ul><h2 id="2-类型、值和变量"><a href="#2-类型、值和变量" class="headerlink" title="2. 类型、值和变量"></a>2. 类型、值和变量</h2><ul><li>对象、数组属于可变类型，数字、字符串、布尔值、<code>null</code>和<code>undefined</code>属于不可变类型。</li><li>任意js的值都可以转换为布尔值。<code>undefined</code>、<code>null</code>、<code>0</code>、<code>-0</code>、<code>NaN</code>、<code>&quot;&quot;</code>会转化成<code>false</code>，其他值都会转换成<code>true</code>。</li><li><code>null</code>是一种特殊的对象。<code>undefined</code>属于<code>undefined</code>类型，变量没有初始化，当查询的对象或数组的属性或元素不存在，如果函数没有返回任何值，引用没有提供实参的函数形参的值都会返回<code>undefined</code>。<code>undefined</code>是预定义的全局变量，不是关键字。<code>==</code>会认为两者相等，<code>.</code>和<code>[]</code>对两者进行操作时都会产生类型错误。若想将他们赋值给变量、属性或作为参数传入函数建议使用<code>null</code>。</li><li>不在任何函数内的js代码可以使用关键字<code>this</code>来引用全局对象。</li><li>在读取字符串、数字和布尔值的属性值时，表现的像对象一样。但如果你给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未被保留下来。</li><li>对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，他们也是不相等的。</li><li><code>x + &quot;&quot;</code>等价于<code>String(x)</code>，<code>+x</code>等价于<code>Number(x)</code>，<code>!!x</code>等价于<code>Boolean(x)</code>。</li><li><code>+</code>、<code>==</code>、<code>!=</code>和关系运算符是唯一执行特殊字符串到原始值的转换方式的运算符。</li><li>使用<code>var</code>语句重复声明变量是合法无害的。若给未声明的变量赋值，js会给全局对象创建一个同名属性。</li><li>函数体内，局部变量的优先级高于同名的全局变量。</li><li>js使用了函数作用域，即在函数内声明的所有变量在函数体内始终是可见的。声明提前：js函数内声明的所有变量都（不包含赋值）被提前至函数体的顶部。</li><li>词法作用域：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。</li></ul><h2 id="3-表达式和运算符"><a href="#3-表达式和运算符" class="headerlink" title="3. 表达式和运算符"></a>3. 表达式和运算符</h2><ul><li>如果表达式后跟一对方括号，则会计算方括号内的表达式的值并将它转换为字符串。只有当属性名称是合法的标识符并且需要知道要访问的属性名时，才能使用<code>.</code>来访问属性。</li><li>如果函数使用<code>return</code>给出一个返回值时，这个返回值就是该表达式的值，否则表达式的值就是<code>undefined</code>。</li><li>如果对象创建表达式不需要传入任何参数给构造函数的话，那么空圆括号是可以省略的。</li><li>构造函数一般不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果该构造函数返回了一个对象值（只能是对象），那么该对象则作为整个表达式的值，而构造函数中新创建的对象就废弃了。</li><li><p>js中子表达式的计算过程中的运算顺序不同于运算符的优先级和结合性规定的运算顺序。js总是严格按照从左至右的顺序来计算表达式的。如计算式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = (a++) + a;</span><br></pre></td></tr></table></figure><ol><li>计算b</li><li>计算a++（结果记为c），之后a的值增1</li><li>计算a</li><li>计算c+a（此时a为2）</li><li>将结果赋值给b</li></ol></li><li><p>所有无法转换为数字的操作数都转化为<code>NaN</code>，若有操作数为<code>NaN</code>，此时计算结果也为<code>NaN</code>。</p></li><li>求余运算中余数的符号和被除数的符号保持一致。</li><li><p>当<code>+</code>与字符串和数字一起使用时，应考虑加法的结合性对运算的影响。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 + 2 + &quot;hello&quot;;//&quot;3hello&quot;</span><br><span class="line">var b = 1 + (2 + &quot;hello&quot;);//&quot;12hello&quot;</span><br></pre></td></tr></table></figure></li><li><p>位运算符的操作数为整数，且为32位整型，若不是则会强制转换。</p><ul><li>左移（&lt;&lt;）新的一位会用0来补充</li><li>右移（&gt;&gt;）新的一位由操作数的符号决定，正数补0，负数补1。</li><li>无符号右移（&gt;&gt;&gt;）新的一位总是补0.</li></ul></li><li>只有数字和字符串才能真正执行比较操作，除此之外的都将进行类型转换。如果一个操作数是（或转换之后是）<code>NaN</code>，则比较结果总为<code>false</code>。字符串比较中大写字母总是小于小写字母。</li><li>in运算符：如果右侧的对象有一个名为左侧操作数的属性名，那么表达式返回<code>true</code>。</li><li>instanceof运算符：左操作数是对象，右操作数是对象的类。若左操作数不是对象，则返回<code>false</code>，若右操作数不是函数，则抛出类型错误异常。</li><li><p><code>&amp;&amp;</code> 和 <code>||</code>的“短路”性质，可用于简写代码：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">    stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(a == b) &amp;&amp; stop();</span><br></pre></td></tr></table></figure></li><li><p>带操作符的赋值运算中需要注意：表达式<code>a op= b</code>和<code>a = a op b</code>的不同点，当a中含有具有副作用的表达式时，两者是不同的。如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//data[i++] *= 2;</span></span><br><span class="line"><span class="comment">//data[i++] = data[i++] * 2;</span></span><br><span class="line">两者计算结果不同，第一个data = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]，第二个data = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>typeof</code>运算符返回表示操作数类型的字符串，可将数组和对象与函数区分开。</p></li><li><code>delete</code>运算符用来删除对象属性或数组元素，删除属性时该属性在对象中不再存在，删除数组元素时，其对应值变为<code>undefined</code>。但通过<code>var</code>声明的变量和定义的函数都不能被删除。</li><li><code>void</code>运算符：操作数会照常计算但是忽略计算结果并返回<code>undefined</code>。常用于url中。</li></ul><h2 id="4-语句"><a href="#4-语句" class="headerlink" title="4. 语句"></a>4. 语句</h2><ul><li>全局变量是全局对象的属性，然而和其他全局变量的属性不同的是，var声明的变量是无法通过delete删除的。</li><li>函数声明语句和函数定义表达式的不同点：<ul><li>函数定义语句中的函数名称和函数体均被显式的提前到脚本或函数的顶部，因此他们在整个脚本和函数内都是可见的。</li><li>使用var声明的函数表达式中只有变量声明被提前了，变量的初始化代码仍在原来的位置。</li></ul></li><li><code>default</code>标签可以放在<code>switch</code>语句的任何位置，并不会影响结果。</li><li><code>while(true)</code>和<code>for(;;)</code>都表示死循环。</li></ul><h2 id="5-对象"><a href="#5-对象" class="headerlink" title="5. 对象"></a>5. 对象</h2><ul><li>如果变量x是指向一个对象的引用，那么执行代码`var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过变量y修改这个对象同样会对变量x的值造成影响。</li><li>对象的属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。同时属性名也可以是标识符，但若属性名含有非法字符或是关键字则需要带上引号。</li><li>用<code>.</code>操作对象时，右侧必须是一个以属性名命名的标识符。用<code>[]</code>操作对象时，方括号内的表达式必须返回一个字符串或者可以转换为字符串的值。</li><li>若要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x，如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者找到一个原型是null的对象为止。</li><li>若给对象o的属性x赋值，如果o中已经有了属性x，那么这个赋值操作只改变这个已有属性x的值；如果o中不存在属性x，那么赋值操作给o添加了新属性x；如果之前o继承了属性x，那么这个继承的属性就被新创建的同名属性覆盖了。</li><li><code>delete</code>只是断开属性和宿主对象的联系，只能删除自有属性而不能删除继承属性，若一定要删除则只能从定义这个属性的原型对象上删除。（但这会影响到所有继承自这个原型的对象）</li><li><code>in</code>运算符可检测是否含有自有属性和继承属性，<code>hasOwnProperty</code>只能检测是否含有自由属性。</li><li>可通过<code>o.x !== undefined</code>判断是否含有某种属性，效果等同于in运算符。（但此种方法不能区分存在但值为undefined的属性）</li><li>for/in循环可以遍历对象中所有可枚举的自有属性和继承属性，但不能枚举继承的内置方法。</li><li><code>Object.keys()</code>返回可枚举的自有属性，<code>Object.getOwnPropertyNames()</code>返回所有自有属性。</li><li>存取器属性<code>getter</code>和<code>setter</code>。</li><li><code>Object.getOwnPropertyDescriptor(Object, attributeName)</code>获得某个对象特定自有属性的属性描述符。</li><li><code>Object.defineProperty(Object, attributeName, descriptorObject)</code>可以设置属性的特性。</li><li>通过对象直接量创建的对象使用<code>Object.prototype</code>作为它的原型，通过new创建的对象使用构造函数的prototype属性作为它的原型，通过<code>Object.create()</code>创建的对象使用第一个参数作为它的原型。</li><li><code>Object.getPrototypeOf()</code>可以查询对象的原型。</li><li><code>ObjectA.isPrototypeOf(ObjectB)</code>检测对象A是否是对象B的原型。</li><li>对象的可扩展性表示是否可以给对象添加新属性。<code>Object.isExtensible()</code>判断对象是否可扩展；<code>ObjectPreventExtensions()</code>将对象转换为不可扩展的，此时再无法将对象转换回可扩展的了，同时这样做只能影响到对象本身的可扩展性，若给一个不可扩展的对象的原型添加属性，则该对象同样会继承这个新属性。</li></ul><h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h2><ul><li>js数组可以是稀疏的，数组元素的索引不一定要连续，他们之间可以有空缺，对于每一个数组都有<code>length</code>属性，针对非稀疏数组，该属性就是数组元素的个数，而对于稀疏数组，该属性值比所有元素的索引都要大。</li><li>数组直接量的语法允许有可选的结尾的逗号，因此<code>var a = [, ,]</code>含有两个<code>undefined</code>值而非三个。</li><li>数组的索引是<strong>0~2^32-2</strong>之间的整数。</li><li>因为数组是对象，因此可以为其创建任意名字的属性，但是如果属性名是数组的索引，数组就会更新它的length属性值。</li><li>可以使用负数或者非整数作为数组的索引，此时数值将转换为字符串来作为属性名使用，此时只能作为属性名而非数组索引。同样，如果使用了非负整数的字符串作为数组索引，它就会直接作为数组索引而非对象的属性值。当使用浮点数作为索引时，若浮点数与一个整数相等则同样方式处理。</li><li>关于<code>length</code>属性：<ul><li>如果为一个数组元素赋值，它的索引 <strong>i</strong> 大于或等于现有数组的长度时，length的属性值将设置为 <strong>i+1</strong></li><li>若设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除。</li></ul></li></ul><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h2><ul><li>函数的定义可以通过函数声明或者函数定义表达式。通过函数声明的方法定义的函数，其名称是必需的部分，函数声明实际上声明了一个变量并把一个函数赋值给它。通过函数定义表达式的方式定义的函数，其名称是可选的，如果它包含名称，函数的局部作用域将会包含一个绑定到该函数对象的名称，函数的名称将成为函数内部的一个局部变量，在比如函数需要递归的情况下是很有用的。</li><li>函数声明语句被提前到外部脚本或外部函数作用域的顶部，所以这种方式声明的函数可以被在它定义之前出现的代码所调用。要调用以表达式定义的函数则需要将函数赋值给一个变量，变量的声明会提前但是变量的赋值是不会提前的。</li><li>函数声明语句不能出现在循环、条件判断、或者try/catch/finally以及with语句中。函数定义表达式则不受限制。</li><li>普通的函数调用中（无论该函数声明是在脚本中还是函数内）的上下文<code>this</code>指的是全局对象（严格模式中是undefined），而方法调用中则指的是调用该方法的对象。</li><li>构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性，构造函数会试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数中的this指的是这个新创建的对象。</li><li>构造函数通常不使用<code>return</code>返回值，因为构造函数会显式返回初始化的新对象，如果使用了return返回一个对象，则调用构造函数返回的就是这个对象，若return返回的是其他值则会忽略该返回值。</li><li>在函数体内标识符<code>arguments</code>是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标来访问传入函数的实参值。</li><li><code>arguments</code>和形参指的是同一个值，修改任意一个值都会影响到另一个。</li><li>函数不仅是一种语法也是值。</li><li>闭包的实现和理解，词法作用域。</li><li><p><code>call()</code>方法和<code>apply()</code>方法可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。对于call函数来说，第一个调用上下文参数之后的所有参数都是要传入的待调用函数的实参；而apply方法则将实参都放入一个数组当中。两种方法的第一个参数都是一个要调用该函数的对象，该函数中的<code>this</code>则指向这个对象。如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">add.call(a, <span class="number">2</span>)<span class="comment">//返回3</span></span><br></pre></td></tr></table></figure></li><li><p><code>bind()</code>方法将函数绑定至某个对象，并返回一个新的函数。如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(y) &#123;</span><br><span class="line">    return this.x + y;</span><br><span class="line">&#125;</span><br><span class="line">var a = &#123;x: 1&#125;;</span><br><span class="line">var g = f.bind(a);</span><br><span class="line">g(2)//返回3</span><br><span class="line">上述过程相当于</span><br><span class="line">a = &#123;x: 1, f: function(y) &#123;return this.x + y&#125;&#125;;</span><br><span class="line">g = a.f;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>Function()</code>构造的函数不使用词法作用域，它的作用域是全局作用域。</p></li><li>js在函数式编程中的使用。</li></ul><h2 id="8-类和模块"><a href="#8-类和模块" class="headerlink" title="8. 类和模块"></a>8. 类和模块</h2><ul><li>定义构造函数即是定义类，因此构造函数名的首字母要大写，而普通的函数和方法名首字母都是小写。</li><li>构造函数不必用<code>return</code>返回值，当通过<code>new</code>关键字来创建新对象时会自动返回该对象。其原型对象的名字为<code>ClassName.prototype</code>，这是一个强制命名，通过该构造函数创建的新对象会自动使用该原型对象作为新创建的对象的原型。</li><li><strong>原型对象是类的唯一标识</strong>，当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例，而初始化该对象的构造函数则不能作为类的标识，两个构造函数的prototype可能指向同一个原型对象，那么这两个构造函数创建的实例是属于同一个类的。</li><li><code>a instanceof A</code>并不会检查a是否是由A()构造函数初始化而来，而是检查a是否继承自A.prototype。</li><li>在希望用到字符串的地方用到对象的话，js会自动调用<code>toString</code>方法，如果没有实现这个方法，类会默认从<code>Object.prototype</code>中继承这个方法。</li><li>代码的模块化很重要，模块是一个独立的js文件，模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。</li><li>所有模块都尽量定义不超过一个全局变量。</li><li>创建模块的过程中，避免污染全局变量的一种方法是使用一个对象作为命名空间。</li></ul><h2 id="9-正则表达式的模式匹配"><a href="#9-正则表达式的模式匹配" class="headerlink" title="9. 正则表达式的模式匹配"></a>9. 正则表达式的模式匹配</h2><p>正则表达式部分在我的另一篇博客中有介绍到：<a href="">javascri正则表达式</a></p><h2 id="10-web浏览器中的javascript"><a href="#10-web浏览器中的javascript" class="headerlink" title="10. web浏览器中的javascript"></a>10. web浏览器中的javascript</h2><ul><li><p>在html文档里嵌入客户端javascript代码有四种方法：</p><ul><li>内联方式，放置在<code>&lt;script&gt;&lt;/script&gt;</code>标签对之间。</li><li>放置在<code>&lt;script&gt;</code>标签的src属性指定的外部文件中。</li><li>放置在html事件处理程序中，如放入onclick的属性值中。</li><li>放在url中，该url使用特殊的”javascript:”协议。</li></ul></li><li><p>当使用<code>src</code>属性时，<code>&lt;script&gt;&lt;/script&gt;</code>之间的任何内容都会忽略。</p></li><li><code>script</code>标记中type属性默认值为”text/javascript”，如果没有指定，则使用默认值。若指定的类型是一个不可执行的类型，则不会从该url中下载任何东西。</li><li>可以通过<code>&lt;a href=&quot;javascript: void doSomethingHere;&quot;&gt;</code>来执行某些操作并且不会修改当前页面文档。</li><li>脚本和事件处理程序在同一时间只能执行一个，没有并发性。</li><li>javascript的时间线。</li></ul><h2 id="11-Window对象"><a href="#11-Window对象" class="headerlink" title="11. Window对象"></a>11. Window对象</h2><ul><li>它是客户端js的全局对象。</li><li><code>Location</code>对象的<code>assign()</code>和<code>replace()</code>方法都可以使窗口载入一个指定的url中的文档，后者在载入新文档之前会将当前文档从浏览历史中删除，此时后退操作无效。</li><li><code>Location</code>对象的<code>reload()</code>方法可以让浏览器重新载入当前文档。</li><li>直接将url赋值给<code>location</code>属性。</li><li>片段标识符不会使浏览器载入新的文档，它只会使它滚动到文档中的某个位置。<code>#id</code>会使浏览器跳到元素id对应的位置。<code>#top</code>如果没有元素id为top的话，则浏览器会跳到文档的开始处。</li><li><code>history</code>属性包含浏览器的浏览历史信息。</li><li><code>navigator</code>属性包含浏览器厂商和版本信息。</li><li><code>screen</code>属性包含窗口大小和可用颜色信息。</li><li>浏览器会为了防止广告的弹出而禁用<code>window.open()</code>方法，只有当用户手动点击按钮或者链接的时候才会调用。</li><li>如果正在事件处理程序中调用<code>close()</code>方法，则应指明是Window对象还是Document对象的close方法。</li><li>即使一个窗口已经关闭，但是代表它的Window对象仍然存在，它的document会使null，它的方法也不会工作。</li><li>Window对象的open()方法会返回新创建的窗口的Window对象，而该对象的opener属性则指向打开该窗口的原始窗口的Window对象。</li><li>窗体是用<code>&lt;iframe&gt;</code>元素创建的，窗体或窗口之间可以互相嵌套，可通过<code>parent</code>引用父窗口或窗体的window对象，<code>top</code>则可直接引用顶级窗口对象。若获取了iframe元素，可通过<code>contentWindow</code>属性获取该窗体的window对象，相反可通过window对象的<code>frameElement</code>得到对应的元素。另外，Window对象中还有frames属性可以得到自身包含的子窗口或窗体的引用，frames属性引用的是类数组对象，数组中的元素是Window对象而不是iframe元素，当访问子窗体时也可通过iframe元素的name或id属性来访问。</li></ul><h2 id="12-脚本化文档"><a href="#12-脚本化文档" class="headerlink" title="12. 脚本化文档"></a>12. 脚本化文档</h2><ul><li><code>Document</code>对象表示窗口的内容。</li><li>在html的树形结构中，树形的根部是<code>Document</code>节点，代表整个文档，代表html元素的是<code>Element</code>节点，代表文本的是<code>Text</code>节点。这三种节点都是Node的子类。</li><li>html的<code>name</code>属性最初是为了表单元素分配名字，在表单数据提交到服务器时使用该属性的值。name属性的值在html文档中不必唯一，并且该属性仅在表单、表单元素、iframe和img这些元素中有效。（<strong>对于IE浏览器，通过<code>getElementById()</code>和<code>getElementsByName()</code>均会返回包含对应id和name的元素，因此不应将同样的字符串用作id和name的值</strong>）</li><li><code>document.documentElement</code>指代文档的根元素，<code>document.head</code>和<code>document.body</code>分别指代head和body元素。</li><li><code>NodeList</code>和<code>HTMLCollection</code>都是类数组对象，因此不能直接使用Array的方法，但可以通过call和apply来间接调用。</li><li><code>querySelectorAll()</code>方法是通过css选择器的方式来匹配元素，但是其返回值并不是实时的，不会随着文档的变化而更新。<code>querySelector()</code>则是返回匹配的第一个元素。</li><li>html中的属性名不区分大小写，但是js中的属性名则大小写敏感。因此html中的属性名在js中全部转换为小写，如果属性名包含不只一个单词，则除第一个单词外其余单词的首字母均大写。另外，有些html属性名在js中是保留字，对于这些属性一般是在属性名前加<strong>html</strong>前缀，例如，<code>for</code>转换为<code>htmlFor</code>，但对于<code>class</code>属性则例外，它转换为<code>className</code>。</li><li>表示html属性的值通常是字符串，但当html属性为布尔值或数字时，js中的属性也是布尔值或者数字。</li><li>HTML5提供任意以<code>data-</code>为前缀的小写的属性名而在元素上绑定一些额外的信息。同时定义了Element对象的dataset属性，该对象的属性对应于上述含前缀的属性。</li><li><code>createElement()</code>和<code>createTextNode()</code>分别用于创建Element节点和Text节点。</li><li>如果通过<code>appendChild()</code>和<code>insertBefore()</code>方法将文档中已经存在的节点插入到文档中，那个节点将会从它当前的位置删除并在新的位置重新插入。</li><li><code>window.pageXOffset</code>、<code>window.pageYOffset</code>、<code>document.documentElement.scrollTop</code>、<code>document.documentElement.scrollLeft</code>都可以得到滚动条的位置信息。</li><li><code>window.innerWidth</code>、<code>window.innerHeight</code>、<code>document.documentElement.clientWidth</code>、<code>document.documentElement.clientHeight</code>都可以得到视口的尺寸信息。</li><li><code>getBoundingClientRect()</code>、<code>getClientRects()</code>可以得到一个元素的尺寸和位置。</li></ul><h2 id="13-脚本化css"><a href="#13-脚本化css" class="headerlink" title="13. 脚本化css"></a>13. 脚本化css</h2><ul><li>style属性中的样式覆盖了样式表中的样式，而且文档的样式表中的样式覆盖了浏览器的默认样式。</li><li>对于<code>absolute</code>和<code>fixed</code>定位，可以通过left和right或top和bottom来设置长和宽，若通过含有width或height，则相应的right和bottom将失效。</li><li><code>z-index</code>属性只对兄弟元素应用堆叠效果。</li><li><code>z-index</code>属性不适用于非定位元素，但对于非定位元素，它的值为0。</li><li>对于定位元素，left和top属性指定了从容器边框内侧到定位元素边框外侧的距离。</li><li>如果css属性名包含多个连字符，在js中应将连字符移除并将每个连字符后紧接着的字母大写。如果css属性名在js中属于保留字，则应在该属性名前加上”css”前缀，如”cssFloat”。</li><li>通过js操作元素的style属性时，所有的值都是字符串，并且对于定位属性，其单位也要写上。</li></ul><h2 id="14-事件处理"><a href="#14-事件处理" class="headerlink" title="14. 事件处理"></a>14. 事件处理</h2><ul><li><code>event</code>对象被当作参数传给事件处理函数，该对象的<code>type</code>属性确定了事件的类型，<code>target</code>属性确定了触发事件的对象。</li><li>当按下键盘按键重复产生字符时，在<code>keyup</code>事件之前会产生多个<code>keypress</code>事件，该事件对象指定的是产生的字符，而不是按键。</li><li><code>addEventListener()</code>能为同一个对象注册同一事件类型的多个处理程序函数，当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。</li><li>使用相同的参数在同一对象上多次调用<code>addEventListener()</code>是没用的，处理程序仍然只注册一次，同时重复调用也不会改变调用处理程序的顺序。</li><li>对于IE9之前不支持<code>addEventListener()</code>、<code>removeEventListener()</code>但支持类似的方法，<code>attachEvent()</code>和<code>detachEvent()</code>。两种方法类似但是存在以下几点不同：<ul><li>只有两个参数</li><li>第一个参数使用了带”on”前缀的事件处理程序名字字符串。</li><li>当给同一对象注册多个同一事件处理程序，事件发生时，会多次触发事件处理程序。</li><li>通过这种方式注册的事件处理程序中的this指的是全局对象，而其他方式指的是目标对象。</li></ul></li><li>事件的调用顺序：<ul><li>通过设置对象属性或html属性注册的处理程序优先调用。</li><li>通过<code>addEventListener()</code>注册的处理程序按照它们的注册顺序调用。</li><li>使用<code>attachEvent()</code>注册的处理程序可能按照任何顺序调用，代码不应依赖于调用顺序。</li></ul></li></ul><h2 id="15-脚本化http"><a href="#15-脚本化http" class="headerlink" title="15. 脚本化http"></a>15. 脚本化http</h2><ul><li>http请求的顺序是：先是请求方法和url，然后是请求头，最后是请求主体。</li></ul><h2 id="16-jquery类库"><a href="#16-jquery类库" class="headerlink" title="16. jquery类库"></a>16. jquery类库</h2><ul><li>this指的是原生文档参数，而不是jquery对象，若想使用jquery方法，则应该写成<code>$(this)</code>。</li><li>jquery中使用同一个方法既当setter又当getter使用，用作setter时，这些方法会给jquery对象中的每一个元素设置值，当作为getter使用时，这些方法只会查询jquery对象中的第一个元素并给它设置值。</li><li><code>css()</code>方法返回的是当前样式，即计算样式，该返回值既可能来自style属性也可能来自样式表。</li><li><code>css()</code>方法不能获取复合样式，但是可以设置复合样式的值，其中的样式名既可以用连字符也可以用驼峰格式。</li><li><code>css()</code>方法在获取样式值时，会把数值转换成带有单位后缀的字符串返回，在设置样式值时，则会将数值转换成字符串并在必要时添加”px”后缀。</li><li><code>offset()</code>方法返回元素的绝对位置，用相对于文档的坐标来表示。<code>position()</code>方法返回相对于元素的<code>offsetParent()</code>的偏移量。</li><li>获取元素的尺寸可以使用以下几种方法:<ul><li><code>width()</code>、<code>height()</code>返回内容的宽度和高度。</li><li><code>innerWidth()</code>、<code>innerHeight()</code>返回包含内边距的宽度和高度。</li><li><code>outerWidth()</code>、<code>outerHeight()</code>返回包含边框的宽度和高度</li><li>若对第三种方法传入参数<code>true</code>则返回的是包含元素外边距的宽度和高度。</li></ul></li><li>如果插入的元素已经是文档的一部分，这些元素只会简单的移动而不是复制到新位置。</li><li>jquery动画只支持数值属性。</li></ul><h2 id="17-客户端存储"><a href="#17-客户端存储" class="headerlink" title="17. 客户端存储"></a>17. 客户端存储</h2><ul><li>浏览器目前只支持存储字符串类型数据，若要存取其他类型的数据，需要手动进行编码和解码。</li></ul><h2 id="18-多媒体和图形编程"><a href="#18-多媒体和图形编程" class="headerlink" title="18. 多媒体和图形编程"></a>18. 多媒体和图形编程</h2><ul><li>通过<code>Image()</code>构造函数来创建一个图片对象，并将其<code>src</code>属性设置为相应的图片的url，这样由于图片元素并没有被添加到文档中，因此它是不可见的，但是浏览器会加载图片并将其缓存起来。当其他部分需要使用到该图片时便可直接从浏览器缓存中获取。</li><li>对于音频元素，可通过<code>new Audio(&quot;url&quot;)</code>来构造一个对象，但视频元素没有类似的构造函数。</li><li>在用<code>canvas</code>绘制图形时，当完成一条路径要绘制另一条路径前应使用<code>beginPath()</code>方法，如果没有使用该方法，那么添加的所有子路径都是处于当前路径上，使用<code>stroke()</code>和<code>fill()</code>方法时会作用在当前路径上的所有子路径。可能会导致重复绘制。</li><li>非零绕数原则：判断一个点是否在路径的内部。</li><li>每个<code>canvas</code>元素只有一个上下文对象，就算多次调用<code>getContext()</code>方法也会返回相同的上下文对象。</li><li>线段宽度是由<code>lineWidth</code>属性和当前坐标系变换决定的，与其他创建路径的方法无关。</li><li>文本对齐<code>textAlign</code>属性中，属性值<code>start</code>和<code>end</code>跟文本的方向有关，若文本是从左到右的则<code>start</code>和<code>left</code>是相同的，否则则相反。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对《javascript权威指南》这本书中的知识点的总结。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/JS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="JS" scheme="http://arlendp.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Git知识总结</title>
    <link href="http://arlendp.me/git/git-knowledge/"/>
    <id>http://arlendp.me/git/git-knowledge/</id>
    <published>2015-12-25T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.465Z</updated>
    
    <content type="html"><![CDATA[<p>git是平常软件开发中经常使用的版本控制系统，本文对git的原理、基础和配置方式进行了介绍，同时总结了平时使用过程中常见的git操作。<br><a id="more"></a></p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><ol><li>集中式版本控制系统：有一个单一的集中管理的服务器，开发人员都可以连接到这台服务器，进行协同工作。</li></ol><ul><li>优点是系统容易管理和维护</li><li>缺点是如果中央服务器出现故障，工作将不能进行</li></ul><ol start="2"><li>分布式版本控制系统：不是只提取最新版本的文件快照，而是将整个代码仓库拷贝到本地，即使服务器故障也能通过本地仓库进行完整的恢复。</li></ol><h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2. 基础"></a>2. 基础</h2><ul><li><p>git保存数据是保存整个文件系统的一个快照<img src="https://git-scm.com/book/en/v2/book/01-introduction/images/snapshots.png" alt="git-snapshot"></p></li><li><p>其他大部分系统保存的是文件的变更信息<img src="https://git-scm.com/book/en/v2/book/01-introduction/images/deltas.png" alt="delta"></p></li><li><p>git大部分操作都是在本地完成的，因此速度很快。即使没有网络，也可以提交文件，之后再上传</p></li><li><p>git通过SHA-1（哈希）计算校验和，由40个十六进制数组成的字符串。git数据库中保存的信息都是通过文件内容的hash值进行索引的而不是文件名。</p></li><li><p>git的三个工作区域</p><ul><li>git仓库：用来保存项目的数据以及数据库，当从其他地方clone项目时，拷贝的就是这里面的数据。</li><li>工作目录：存放的是项目某个版本的内容，存放于磁盘可供修改等操作，来源于git仓库中的压缩数据库。</li><li>暂存区域： 是一个文件，保存了将提交的文件信息。</li></ul></li><li><p>git工作流程</p><ul><li>在工作目录中修改文件(modified)</li><li>将修改的文件暂存在暂存区域(staged)</li><li>提交更新，将暂存区的文件存储到git仓库中(commited)</li></ul></li></ul><h2 id="3-git配置"><a href="#3-git配置" class="headerlink" title="3. git配置"></a>3. git配置</h2><p>git config</p><ul><li>–system：系统上所有用户及仓库的通用配置</li><li>–global：针对当前用户的配置</li><li>–config：针对当前仓库的配置</li></ul><p>上述配置具有优先级，由上往下递增，高优先级的覆盖低优先级的配置。</p><p>第一次使用时会配置个人信息<br><code>$ git config --global user.name yourname</code><br><code>$ git config --global user.email your@email.com</code><br>这些信息会写入每一次提交中，该配置只需配置一次。若想对某个项目使用特定的用户信息，通过git config来配置。<br>可通过git config –list查看所有配置信息，也可通过如git config user.name来查看用户名</p><h2 id="4-git基础操作"><a href="#4-git基础操作" class="headerlink" title="4. git基础操作"></a>4. git基础操作</h2><h3 id="4-1-创建git仓库"><a href="#4-1-创建git仓库" class="headerlink" title="4.1 创建git仓库"></a>4.1 创建git仓库</h3><ul><li>在已有项目中创建git仓库：通过<code>$ git init</code>命令创建一个.git子目录，里面存储了git仓库初始化时的必须文件，但不包括项目文件。</li><li>克隆仓库：通过<code>$ git clone theUrlYouWantToClone</code>，会克隆该仓库的所有版本的文件而不是最新版本的文件。执行该操作后会在当前目录下创建一个与该仓库同名的目录，并在该目录下初始化一个<code>.git</code>文件夹，将远程仓库中的数据拉取到该文件夹，并从中读取最新版本的项目文件，拷贝至其同级目录。<ul><li>可通过<code>$ git clone theUrlYouWantToClone myProjectName</code>修改仓库名称</li></ul></li></ul><p><strong><code>theUrlYouWantToClone</code></strong>可支持多种协议，git中常用到的是https、git和SSH协议。</p><h3 id="4-2-文件状态"><a href="#4-2-文件状态" class="headerlink" title="4.2 文件状态"></a>4.2 文件状态</h3><p>文件具有两种状态<strong>已跟踪</strong>和<strong>未跟踪</strong>。</p><ul><li>已跟踪的文件指的是已被纳入版本控制的文件，它们可能处于<em>未修改</em>、<em>已修改</em>、<em>已暂存</em>等状态。</li><li>将文件从git中移除、新建立一个文件等操作产生的文件都会处于未跟踪状态。<br>git版本控制下文件的生命周期<br><img src="https://git-scm.com/book/en/v2/book/02-git-basics/images/lifecycle.png" alt="life-cycle"></li></ul><h3 id="4-3-git-add命令"><a href="#4-3-git-add命令" class="headerlink" title="4.3 git add命令"></a>4.3 git add命令</h3><h4 id="4-3-1-跟踪新文件"><a href="#4-3-1-跟踪新文件" class="headerlink" title="4.3.1 跟踪新文件"></a>4.3.1 跟踪新文件</h4><p>通过<code>$ git add filename</code>、<code>$ git add pathname</code>可分别跟踪某个文件和某个路径下的所有文件，或者通过<code>$ git add .</code>来跟踪所有文件。</p><h4 id="4-3-2-暂存已修改文件"><a href="#4-3-2-暂存已修改文件" class="headerlink" title="4.3.2 暂存已修改文件"></a>4.3.2 暂存已修改文件</h4><p>与上述方法相同</p><p>因此，<code>git add</code>具有多种功能，可理解为<strong>向下次提交中添加内容</strong></p><h3 id="4-4-git-status命令"><a href="#4-4-git-status命令" class="headerlink" title="4.4 git status命令"></a>4.4 git status命令</h3><p>该命令用于查看文件状态<br>也可通过<code>$ git status -s</code>或者<code>$ git status --short</code>查看简写的文件状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><p>各种记号的解释如下：</p><ul><li>??：未跟踪文件</li><li>A：新添加到暂存区的文件</li><li>_M：文件被修改但未添加到暂存区</li><li>M_：文件被修改且已添加到暂存区</li><li>MM：文件被修改且已添加到暂存区后又被修改</li></ul><h3 id="4-5-gitignore文件"><a href="#4-5-gitignore文件" class="headerlink" title="4.5 .gitignore文件"></a>4.5 .gitignore文件</h3><p>忽略文件的具体格式可见<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件" target="_blank" rel="noopener">忽略文件</a></p><h3 id="4-6-git-diff命令"><a href="#4-6-git-diff命令" class="headerlink" title="4.6 git diff命令"></a>4.6 git diff命令</h3><p>git diff命令用于查看文件的修改，与git status相比可以具体显示修改的内容。</p><ul><li><code>$ git diff</code>显示的是已修改但未暂存的文件内容</li><li><code>$ git diff --cached</code>或<code>$ git diff --staged</code>查看已暂存但未提交的内容</li></ul><h3 id="4-7-git-commit命令"><a href="#4-7-git-commit命令" class="headerlink" title="4.7 git commit命令"></a>4.7 git commit命令</h3><p>通过git commit命令可将暂存区内的文件进行提交，而未暂存的文件则不会被提交。<br>可用<code>$ git commit</code>命令按提示完成提交或直接通过<code>$ git commit -m &quot;yourComments&quot;</code>进行提交说明并提交。<br>若想对所有已暂存和未暂存的文件进行提交可使用<code>$ git commit -a -m &quot;yourComments&quot;</code>进行提交，这样可简化操作步骤。</p><h3 id="4-8-移除文件"><a href="#4-8-移除文件" class="headerlink" title="4.8 移除文件"></a>4.8 移除文件</h3><p>移除文件需要git remove操作。</p><ul><li>通过<code>$ git rm fileName</code>即可将文件移出git版本控制并同时删除工作区中的文件，之后执行commit操作提交即可。</li><li>若是直接手动将文件删除，此时文件将会处于未暂存状态，通过git add或git rm操作便可进入已暂存状态，之后执行commit操作即可。</li><li>若文件进过修改并送入暂存区，需要用<code>$ git rm -f fileName</code>才能强制删除或通过上述第一种方式删除。</li><li>若是要将文件从git版本控制中删除但又不想从工作区中删除，则可通过<code>$ git rm --cached fileName</code>命令来实现。</li></ul><h3 id="4-9-移动文件"><a href="#4-9-移动文件" class="headerlink" title="4.9 移动文件"></a>4.9 移动文件</h3><p>移动文件操作通过<code>$ git mv fileFrom fileTo</code>来实现，该操作执行过程实际上是执行了删除fileFrom文件之后添加fileTo文件。</p><h3 id="4-10-撤销操作"><a href="#4-10-撤销操作" class="headerlink" title="4.10 撤销操作"></a>4.10 撤销操作</h3><ol><li><p>修改提交文件</p><ul><li>若提交后发现漏掉其他文件，可通过<code>$ git commit --amend</code>操作将当前暂存区的文件加入上次提交中，相当于只存在一次提交。</li><li>若是想修改提交文件的提交信息，可通过<code>$ git commit --amend -m &quot;newComments&quot;</code></li></ul></li><li><p>取消暂存文件</p><ul><li>通过<code>$ git reset HEAD fileName</code>可将文件从暂存区中移除，进入未暂存状态。</li></ul></li><li><p>取消已修改文件</p><ul><li>通过<code>$ git checkout -- fileName</code>将已修改的文件还原至上一次未修改时的状态。</li></ul></li></ol><h3 id="4-11-远程仓库"><a href="#4-11-远程仓库" class="headerlink" title="4.11 远程仓库"></a>4.11 远程仓库</h3><p>git项目的协作时会用到远程仓库，当克隆一个项目时，会有一个默认的名为<strong>origin</strong>的远程仓库。</p><ul><li>可通过<code>$ git remote</code>查看所有远程仓库或<code>$ git remote -v</code>查看所有远程仓库的具体信息。通过<code>$ git remote show remoteName</code>查看指定远程仓库的详细信息。</li><li>通过<code>$ git remote add shortNameForTheRemoteRepository RepositoryUrl</code></li><li>通过<code>$ git fetch shortName</code>可获取该远程仓库中的所有信息，但不会合并或修改当前工作区的文件</li><li>通过<code>$ git pull</code>命令获取远程仓库的数据并合并到当前分支，默认情况下，本地的master分支会跟踪远程仓库的master分支。</li><li>通过<code>$ git push remoteName branchName</code>将当前分支推送到指定远程仓库的指定分支上。</li><li>重命名远程仓库可使用<code>$ git remote rename originalName currentName</code></li><li>删除远程仓库可使用<code>$ git remote rm repositoryName</code></li></ul><h2 id="5-git分支"><a href="#5-git分支" class="headerlink" title="5. git分支"></a>5. git分支</h2><p>使用分支可以将开发工作从主线上进行分离，git的默认分支是<strong>master</strong>分支。git使用<strong>HEAD</strong>指针指向当前分支，可看做当前分支的一个别名。</p><h3 id="5-1-创建分支"><a href="#5-1-创建分支" class="headerlink" title="5.1 创建分支"></a>5.1 创建分支</h3><p>创建分支实际上就是创建了一个指向当前项目的指针，通过<code>$ git branch</code>命令可以查看当前分支，<code>$ git branch branchName</code>用于创建分支。</p><h3 id="5-2-切换分支"><a href="#5-2-切换分支" class="headerlink" title="5.2 切换分支"></a>5.2 切换分支</h3><p>命令<code>$ git checkout branchName</code>用于切换分支，切换分支后当前的工作区的文件也会随之改变。<br><strong>git分支是以提交的文件为基础的，一般情况下在修改文件后只有当提交了文件才能切换到另一个分支，但也有特殊情况，以branch1和branch2两个分支为例，若在branch1中添加了新文件，此时切换到branch2分支可以看到该文件，若此时提交则该文件属于branch2分支，再次切回branch1中不会保留该文件</strong></p><h3 id="5-3-删除分支"><a href="#5-3-删除分支" class="headerlink" title="5.3 删除分支"></a>5.3 删除分支</h3><p>通过<code>$ git branch -d branchName</code>可以删除该分支</p><h3 id="5-4-分支合并"><a href="#5-4-分支合并" class="headerlink" title="5.4 分支合并"></a>5.4 分支合并</h3><p>首先通过<code>$ git checkout branchName</code>切换到某一分支，如master分支，接下来执行<code>$ git merge branchName</code>将对应分支合并到master中。<br><strong>合并过程中如果两个分支对同一个文件进行了操作，则会产生冲突，需要手动解决，产生冲突的内容会在工作区中的相应文件中被标记出来，需要自己去判断保留哪一份修改，之后执行提交即可。</strong></p><h3 id="5-5-跟踪远程分支"><a href="#5-5-跟踪远程分支" class="headerlink" title="5.5 跟踪远程分支"></a>5.5 跟踪远程分支</h3><p>若想跟踪远程分支可以通过<code>$ git checkout --track remoteRepository/remoteBranch</code>，也可通过<code>$ git checkout -b branchName remoteRepository/remoteBranch</code>新建分支并跟踪远程分支，两者的不同点只是新建分支的名字不同。<br>若本地已有分支，则可通过<code>$ git branch -u remoteRepository/remoteBranch</code>添加或修改跟踪。<br>通过<code>$ git branch -vv</code>命令可以查看远程分支的跟踪信息。</p><h3 id="5-6-删除远程分支"><a href="#5-6-删除远程分支" class="headerlink" title="5.6 删除远程分支"></a>5.6 删除远程分支</h3><p>命令<code>$ git push remoteRepository --delete remoteBranch</code>可用于删除远程分支。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git是平常软件开发中经常使用的版本控制系统，本文对git的原理、基础和配置方式进行了介绍，同时总结了平时使用过程中常见的git操作。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://arlendp.me/categories/Git/"/>
    
    
      <category term="Git" scheme="http://arlendp.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>CSS实现元素的垂直居中</title>
    <link href="http://arlendp.me/web/css/element-vertical-centering-by-css/"/>
    <id>http://arlendp.me/web/css/element-vertical-centering-by-css/</id>
    <published>2015-11-21T16:00:00.000Z</published>
    <updated>2018-04-15T06:37:33.464Z</updated>
    
    <content type="html"><![CDATA[<p>垂直居中指的是将元素在垂直方向上相对于父级元素达到一种居中的效果，在我们平时的布局中也会经常碰到垂直居中，在这里总结了下通过css实现垂直居中的各种常见方法，在使用各种方法时也要考虑到使用的场景。<br><a id="more"></a></p><p>以下css样式所应用到的html代码均如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>要达到的效果是box相对于content实现垂直居中。</p><p>以下是各种实现方法总结：</p><h2 id="1-元素高度已知"><a href="#1-元素高度已知" class="headerlink" title="1. 元素高度已知"></a>1. 元素高度已知</h2><ol><li><p>已知尺寸的块可以通过绝对定位和margin进行垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">    display: relative;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.content .box &#123;</span><br><span class="line">    display: absolute;</span><br><span class="line">    height: 100px;</span><br><span class="line">    top: 50%;</span><br><span class="line">    margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意：通过这种方式元素被设置成了绝对定位，脱离了文档流，会对后面的元素位置产生影响。</p></li><li><p>通过在box前设置一个浮动的空块来实现垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.floater &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    height: 50%;</span><br><span class="line">    margin-bottom: -100px;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.content .box &#123;</span><br><span class="line">    clear: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意：通过这种方式多用了一个空元素，同时因为使用了浮动元素所以应记得清除。</p></li></ol><h2 id="2-元素高度未知"><a href="#2-元素高度未知" class="headerlink" title="2. 元素高度未知"></a>2. 元素高度未知</h2><ol><li><p>通过table-cell元素的垂直居中属性实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">     display: table;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .content .box &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 或直接通过table布局，table-cell的vertical-align:middle默认属性，但两者具有区别。</p></li><li><p>通过after或before伪类和vertical-align实现垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.content .box &#123;</span><br><span class="line">    width: auto;</span><br><span class="line">    height: auto;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content:after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    height: 100%;</span><br><span class="line">    width: 0;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意：定位元素需要设置为inline-block，同时都需要设置vertical-align:center属性。</p></li><li><p>通过margin:auto自动填充外边距实现垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">    position:relative;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.content .box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    height: 200px;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin-top: auto;</span><br><span class="line">    margin-bottom: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意：因为使用了绝对定位脱离了文档流，要考虑到对父元素和兄弟元素位置的影响。</p></li><li><p>通过transform属性的translateY()实现垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">    position: relative;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .content .box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translateY(-50%);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 注意：使用了绝对定位，元素脱离文档流。同时使用时注意兼容性，不支持IE9以下的浏览器，对于部分版本浏览器需加上-ms-、-webkit-等前缀。</p></li><li><p>通过flexbox实现垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: center;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 注意：弹性盒改变了块模型，它可以自动调整子元素使得定位子元素更加容易。它有自己的一些属性，使用了另一种不同的布局逻辑，会使部分元素属性失效，如float和vertical-align。</p></li></ol><p><strong>小结：对于元素的垂直居中的情况判断一般是以该元素的高度是否已知，对于高度已知的情况，上述通过绝对定位和margin—top或通过增加一个浮动的空块均可解决，对于高度未知的情况，通过table布局、vartical-align属性、弹性盒、绝对定位与margin:auto的配合使用或是transfer属性都可实现垂直居中的布局。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垂直居中指的是将元素在垂直方向上相对于父级元素达到一种居中的效果，在我们平时的布局中也会经常碰到垂直居中，在这里总结了下通过css实现垂直居中的各种常见方法，在使用各种方法时也要考虑到使用的场景。&lt;br&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="http://arlendp.me/categories/Web%E5%BC%80%E5%8F%91/CSS/"/>
    
    
      <category term="Web开发" scheme="http://arlendp.me/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="http://arlendp.me/tags/CSS/"/>
    
  </entry>
  
</feed>
